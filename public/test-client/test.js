/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@scure/base/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@scure/base/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;\nfunction assertNumber(n) {\n  if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\nexports.assertNumber = assertNumber;\nfunction chain(...args) {\n  const wrap = (a, b) => c => a(b(c));\n  const encode = Array.from(args).reverse().reduce((acc, i) => acc ? wrap(acc, i.encode) : i.encode, undefined);\n  const decode = args.reduce((acc, i) => acc ? wrap(acc, i.decode) : i.decode, undefined);\n  return {\n    encode,\n    decode\n  };\n}\nfunction alphabet(alphabet) {\n  return {\n    encode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('alphabet.encode input should be an array of numbers');\n      return digits.map(i => {\n        assertNumber(i);\n        if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n        return alphabet[i];\n      });\n    },\n    decode: input => {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('alphabet.decode input should be array of strings');\n      return input.map(letter => {\n        if (typeof letter !== 'string') throw new Error(`alphabet.decode: not string element=${letter}`);\n        const index = alphabet.indexOf(letter);\n        if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n        return index;\n      });\n    }\n  };\n}\nfunction join(separator = '') {\n  if (typeof separator !== 'string') throw new Error('join separator should be string');\n  return {\n    encode: from => {\n      if (!Array.isArray(from) || from.length && typeof from[0] !== 'string') throw new Error('join.encode input should be array of strings');\n      for (let i of from) if (typeof i !== 'string') throw new Error(`join.encode: non-string input=${i}`);\n      return from.join(separator);\n    },\n    decode: to => {\n      if (typeof to !== 'string') throw new Error('join.decode input should be string');\n      return to.split(separator);\n    }\n  };\n}\nfunction padding(bits, chr = '=') {\n  assertNumber(bits);\n  if (typeof chr !== 'string') throw new Error('padding chr should be string');\n  return {\n    encode(data) {\n      if (!Array.isArray(data) || data.length && typeof data[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n      for (let i of data) if (typeof i !== 'string') throw new Error(`padding.encode: non-string input=${i}`);\n      while (data.length * bits % 8) data.push(chr);\n      return data;\n    },\n    decode(input) {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n      for (let i of input) if (typeof i !== 'string') throw new Error(`padding.decode: non-string input=${i}`);\n      let end = input.length;\n      if (end * bits % 8) throw new Error('Invalid padding: string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        if (!((end - 1) * bits % 8)) throw new Error('Invalid padding: string has too much padding');\n      }\n      return input.slice(0, end);\n    }\n  };\n}\nfunction normalize(fn) {\n  if (typeof fn !== 'function') throw new Error('normalize fn should be function');\n  return {\n    encode: from => from,\n    decode: to => fn(to)\n  };\n}\nfunction convertRadix(data, from, to) {\n  if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n  if (!Array.isArray(data)) throw new Error('convertRadix: data should be array');\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data);\n  digits.forEach(d => {\n    assertNumber(d);\n    if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n  });\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < digits.length; i++) {\n      const digit = digits[i];\n      const digitBase = from * carry + digit;\n      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      carry = digitBase % to;\n      digits[i] = Math.floor(digitBase / to);\n      if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');\n      if (!done) continue;else if (!digits[i]) pos = i;else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\nconst gcd = (a, b) => !b ? a : gcd(b, a % b);\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n  if (!Array.isArray(data)) throw new Error('convertRadix2: data should be array');\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n  }\n  let carry = 0;\n  let pos = 0;\n  const mask = 2 ** to - 1;\n  const res = [];\n  for (const n of data) {\n    assertNumber(n);\n    if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = carry << from | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push((carry >> pos - to & mask) >>> 0);\n    carry &= 2 ** pos - 1;\n  }\n  carry = carry << to - pos & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\nfunction radix(num) {\n  assertNumber(num);\n  return {\n    encode: bytes => {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), 2 ** 8, num);\n    },\n    decode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix.decode input should be array of strings');\n      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n    }\n  };\n}\nfunction radix2(bits, revPadding = false) {\n  assertNumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');\n  return {\n    encode: bytes => {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix2.decode input should be array of strings');\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    }\n  };\n}\nfunction unsafeWrapper(fn) {\n  if (typeof fn !== 'function') throw new Error('unsafeWrapper fn should be function');\n  return function (...args) {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\nfunction checksum(len, fn) {\n  assertNumber(len);\n  if (typeof fn !== 'function') throw new Error('checksum fn should be function');\n  return {\n    encode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.encode: input should be Uint8Array');\n      const checksum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(checksum, data.length);\n      return res;\n    },\n    decode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const newChecksum = fn(payload).slice(0, len);\n      const oldChecksum = data.slice(-len);\n      for (let i = 0; i < len; i++) if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    }\n  };\n}\nexports.utils = {\n  alphabet,\n  chain,\n  checksum,\n  radix,\n  radix2,\n  join,\n  padding\n};\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize(s => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = abc => chain(radix(58), alphabet(abc), join(''));\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexports.base58xmr = {\n  encode(data) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n    }\n    return res;\n  },\n  decode(str) {\n    let res = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = exports.base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  }\n};\nconst base58check = sha256 => chain(checksum(4, data => sha256(sha256(data))), exports.base58);\nexports.base58check = base58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n  }\n  return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ c >> 5;\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n  function encode(prefix, words, limit = 90) {\n    if (typeof prefix !== 'string') throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n    if (!Array.isArray(words) || words.length && typeof words[0] !== 'number') throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n    const actualLength = prefix.length + 7 + words.length;\n    if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    prefix = prefix.toLowerCase();\n    return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n  }\n  function decode(str, limit = 90) {\n    if (typeof str !== 'string') throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n    if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n    str = lowered;\n    const sepIndex = str.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = str.slice(0, sepIndex);\n    const _words = str.slice(sepIndex + 1);\n    if (_words.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!_words.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return {\n      prefix,\n      words\n    };\n  }\n  const decodeUnsafe = unsafeWrapper(decode);\n  function decodeToBytes(str) {\n    const {\n      prefix,\n      words\n    } = decode(str, false);\n    return {\n      prefix,\n      words,\n      bytes: fromWords(words)\n    };\n  }\n  return {\n    encode,\n    decode,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords\n  };\n}\nexports.bech32 = genBech32('bech32');\nexports.bech32m = genBech32('bech32m');\nexports.utf8 = {\n  encode: data => new TextDecoder().decode(data),\n  decode: str => new TextEncoder().encode(str)\n};\nexports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize(s => {\n  if (typeof s !== 'string' || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n  return s.toLowerCase();\n}));\nconst CODERS = {\n  utf8: exports.utf8,\n  hex: exports.hex,\n  base16: exports.base16,\n  base32: exports.base32,\n  base64: exports.base64,\n  base64url: exports.base64url,\n  base58: exports.base58,\n  base58xmr: exports.base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nconst bytesToString = (type, bytes) => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!(bytes instanceof Uint8Array)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString;\nconst stringToBytes = (type, str) => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/base/lib/index.js?");

/***/ }),

/***/ "./node_modules/@scure/bip39/index.js":
/*!********************************************!*\
  !*** ./node_modules/@scure/bip39/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;\n/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nconst _assert_1 = __webpack_require__(/*! @noble/hashes/_assert */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/_assert.js\");\nconst pbkdf2_1 = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/pbkdf2.js\");\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/sha256.js\");\nconst sha512_1 = __webpack_require__(/*! @noble/hashes/sha512 */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/sha512.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/utils.js\");\nconst base_1 = __webpack_require__(/*! @scure/base */ \"./node_modules/@scure/base/lib/index.js\");\n// Japanese wordlist\nconst isJapanese = wordlist => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093';\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\nfunction nfkd(str) {\n  if (typeof str !== 'string') throw new TypeError(`Invalid mnemonic type: ${typeof str}`);\n  return str.normalize('NFKD');\n}\nfunction normalize(str) {\n  const norm = nfkd(str);\n  const words = norm.split(' ');\n  if (![12, 15, 18, 21, 24].includes(words.length)) throw new Error('Invalid mnemonic');\n  return {\n    nfkd: norm,\n    words\n  };\n}\nfunction assertEntropy(entropy) {\n  _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nfunction generateMnemonic(wordlist, strength = 128) {\n  _assert_1.default.number(strength);\n  if (strength % 32 !== 0 || strength > 256) throw new TypeError('Invalid entropy');\n  return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);\n}\nexports.generateMnemonic = generateMnemonic;\nconst calcChecksum = entropy => {\n  // Checksum is ent.length/4 bits long\n  const bitsLeft = 8 - entropy.length / 4;\n  // Zero rightmost \"bitsLeft\" bits in byte\n  // For example: bitsLeft=4 val=10111101 -> 10110000\n  return new Uint8Array([(0, sha256_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n  if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string') throw new Error('Worlist: expected array of 2048 strings');\n  wordlist.forEach(i => {\n    if (typeof i !== 'string') throw new Error(`Wordlist: non-string element: ${i}`);\n  });\n  return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  const {\n    words\n  } = normalize(mnemonic);\n  const entropy = getCoder(wordlist).decode(words);\n  assertEntropy(entropy);\n  return entropy;\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nfunction entropyToMnemonic(entropy, wordlist) {\n  assertEntropy(entropy);\n  const words = getCoder(wordlist).encode(entropy);\n  return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\nexports.entropyToMnemonic = entropyToMnemonic;\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */\nfunction validateMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\nexports.validateMnemonic = validateMnemonic;\nconst salt = passphrase => nfkd(`mnemonic${passphrase}`);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nfunction mnemonicToSeed(mnemonic, passphrase = '') {\n  return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), {\n    c: 2048,\n    dkLen: 64\n  });\n}\nexports.mnemonicToSeed = mnemonicToSeed;\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nfunction mnemonicToSeedSync(mnemonic, passphrase = '') {\n  return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), {\n    c: 2048,\n    dkLen: 64\n  });\n}\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip39/index.js?");

/***/ }),

/***/ "./node_modules/@scure/bip39/node_modules/@noble/hashes/_assert.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/_assert.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;\nfunction number(n) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\nexports.bool = bool;\nfunction bytes(b, ...lengths) {\n  if (!(b instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length)) throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nexports.exists = exists;\nfunction output(out, instance) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\nexports.output = output;\nconst assert = {\n  number,\n  bool,\n  bytes,\n  hash,\n  exists,\n  output\n};\nexports[\"default\"] = assert;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip39/node_modules/@noble/hashes/_assert.js?");

/***/ }),

/***/ "./node_modules/@scure/bip39/node_modules/@noble/hashes/_sha2.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/_sha2.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.SHA2 = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number(value >> _32n & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends utils_js_1.Hash {\n  constructor(blockLen, outputLen, padOffset, isLE) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.finished = false;\n    this.length = 0;\n    this.pos = 0;\n    this.destroyed = false;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = (0, utils_js_1.createView)(this.buffer);\n  }\n  update(data) {\n    _assert_js_1.default.exists(this);\n    const {\n      view,\n      buffer,\n      blockLen\n    } = this;\n    data = (0, utils_js_1.toBytes)(data);\n    const len = data.length;\n    for (let pos = 0; pos < len;) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = (0, utils_js_1.createView)(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out) {\n    _assert_js_1.default.exists(this);\n    _assert_js_1.default.output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const {\n      buffer,\n      view,\n      blockLen,\n      isLE\n    } = this;\n    let {\n      pos\n    } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = (0, utils_js_1.createView)(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const {\n      buffer,\n      outputLen\n    } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to) {\n    to || (to = new this.constructor());\n    to.set(...this.get());\n    const {\n      blockLen,\n      buffer,\n      length,\n      finished,\n      destroyed,\n      pos\n    } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\nexports.SHA2 = SHA2;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip39/node_modules/@noble/hashes/_sha2.js?");

/***/ }),

/***/ "./node_modules/@scure/bip39/node_modules/@noble/hashes/_u64.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/_u64.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.add = exports.toBig = exports.split = exports.fromBig = void 0;\nconst U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n  if (le) return {\n    h: Number(n & U32_MASK64),\n    l: Number(n >> _32n & U32_MASK64)\n  };\n  return {\n    h: Number(n >> _32n & U32_MASK64) | 0,\n    l: Number(n & U32_MASK64) | 0\n  };\n}\nexports.fromBig = fromBig;\nfunction split(lst, le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const {\n      h,\n      l\n    } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\nexports.split = split;\nconst toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, l, s) => h >>> s;\nconst shrSL = (h, l, s) => h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s) => h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h, l) => l;\nconst rotr32L = (h, l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s) => l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nfunction add(Ah, Al, Bh, Bl) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return {\n    h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n    l: l | 0\n  };\n}\nexports.add = add;\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\nconst u64 = {\n  fromBig,\n  split,\n  toBig: exports.toBig,\n  shrSH,\n  shrSL,\n  rotrSH,\n  rotrSL,\n  rotrBH,\n  rotrBL,\n  rotr32H,\n  rotr32L,\n  rotlSH,\n  rotlSL,\n  rotlBH,\n  rotlBL,\n  add,\n  add3L,\n  add3H,\n  add4L,\n  add4H,\n  add5H,\n  add5L\n};\nexports[\"default\"] = u64;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip39/node_modules/@noble/hashes/_u64.js?");

/***/ }),

/***/ "./node_modules/@scure/bip39/node_modules/@noble/hashes/cryptoBrowser.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/cryptoBrowser.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.crypto = void 0;\nexports.crypto = {\n  node: undefined,\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n};\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip39/node_modules/@noble/hashes/cryptoBrowser.js?");

/***/ }),

/***/ "./node_modules/@scure/bip39/node_modules/@noble/hashes/hmac.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/hmac.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.hmac = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/utils.js\");\n// HMAC (RFC 2104)\nclass HMAC extends utils_js_1.Hash {\n  constructor(hash, _key) {\n    super();\n    this.finished = false;\n    this.destroyed = false;\n    _assert_js_1.default.hash(hash);\n    const key = (0, utils_js_1.toBytes)(_key);\n    this.iHash = hash.create();\n    if (typeof this.iHash.update !== 'function') throw new TypeError('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create();\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf) {\n    _assert_js_1.default.exists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out) {\n    _assert_js_1.default.exists(this);\n    _assert_js_1.default.bytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to) {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to || (to = Object.create(Object.getPrototypeOf(this), {}));\n    const {\n      oHash,\n      iHash,\n      finished,\n      destroyed,\n      blockLen,\n      outputLen\n    } = this;\n    to = to;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key) => new HMAC(hash, key);\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip39/node_modules/@noble/hashes/hmac.js?");

/***/ }),

/***/ "./node_modules/@scure/bip39/node_modules/@noble/hashes/pbkdf2.js":
/*!************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/pbkdf2.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.pbkdf2Async = exports.pbkdf2 = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/_assert.js\");\nconst hmac_js_1 = __webpack_require__(/*! ./hmac.js */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/hmac.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/utils.js\");\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n  _assert_js_1.default.hash(hash);\n  const opts = (0, utils_js_1.checkOpts)({\n    dkLen: 32,\n    asyncTick: 10\n  }, _opts);\n  const {\n    c,\n    dkLen,\n    asyncTick\n  } = opts;\n  _assert_js_1.default.number(c);\n  _assert_js_1.default.number(dkLen);\n  _assert_js_1.default.number(asyncTick);\n  if (c < 1) throw new Error('PBKDF2: iterations (c) should be >= 1');\n  const password = (0, utils_js_1.toBytes)(_password);\n  const salt = (0, utils_js_1.toBytes)(_salt);\n  // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n  const DK = new Uint8Array(dkLen);\n  // U1 = PRF(Password, Salt + INT_32_BE(i))\n  const PRF = hmac_js_1.hmac.create(hash, password);\n  const PRFSalt = PRF._cloneInto().update(salt);\n  return {\n    c,\n    dkLen,\n    asyncTick,\n    DK,\n    PRF,\n    PRFSalt\n  };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n  PRF.destroy();\n  PRFSalt.destroy();\n  if (prfW) prfW.destroy();\n  u.fill(0);\n  return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nfunction pbkdf2(hash, password, salt, opts) {\n  const {\n    c,\n    dkLen,\n    DK,\n    PRF,\n    PRFSalt\n  } = pbkdf2Init(hash, password, salt, opts);\n  let prfW; // Working copy\n  const arr = new Uint8Array(4);\n  const view = (0, utils_js_1.createView)(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 + ⋯ + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    for (let ui = 1; ui < c; ui++) {\n      // Uc = PRF(Password, Uc−1)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    }\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nexports.pbkdf2 = pbkdf2;\nasync function pbkdf2Async(hash, password, salt, opts) {\n  const {\n    c,\n    dkLen,\n    asyncTick,\n    DK,\n    PRF,\n    PRFSalt\n  } = pbkdf2Init(hash, password, salt, opts);\n  let prfW; // Working copy\n  const arr = new Uint8Array(4);\n  const view = (0, utils_js_1.createView)(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 + ⋯ + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, i => {\n      // Uc = PRF(Password, Uc−1)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    });\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nexports.pbkdf2Async = pbkdf2Async;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip39/node_modules/@noble/hashes/pbkdf2.js?");

/***/ }),

/***/ "./node_modules/@scure/bip39/node_modules/@noble/hashes/sha256.js":
/*!************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/sha256.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.sha224 = exports.sha256 = void 0;\nconst _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/_sha2.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/utils.js\");\n// Choice: a ? b : c\nconst Chi = (a, b, c) => a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => a & b ^ a & c ^ b & c;\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js_1.SHA2 {\n  constructor() {\n    super(64, 32, 8, false);\n    // We cannot use array here since array allows indexing by variable\n    // which means optimizer/compiler cannot use registers.\n    this.A = IV[0] | 0;\n    this.B = IV[1] | 0;\n    this.C = IV[2] | 0;\n    this.D = IV[3] | 0;\n    this.E = IV[4] | 0;\n    this.F = IV[5] | 0;\n    this.G = IV[6] | 0;\n    this.H = IV[7] | 0;\n  }\n  get() {\n    const {\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H\n    } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  set(A, B, C, D, E, F, G, H) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  process(view, offset) {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;\n      const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;\n      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let {\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H\n    } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n      const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n      const T2 = sigma0 + Maj(A, B, C) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = D + T1 | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = T1 + T2 | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = A + this.A | 0;\n    B = B + this.B | 0;\n    C = C + this.C | 0;\n    D = D + this.D | 0;\n    E = E + this.E | 0;\n    F = F + this.F | 0;\n    G = G + this.G | 0;\n    H = H + this.H | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  constructor() {\n    super();\n    this.A = 0xc1059ed8 | 0;\n    this.B = 0x367cd507 | 0;\n    this.C = 0x3070dd17 | 0;\n    this.D = 0xf70e5939 | 0;\n    this.E = 0xffc00b31 | 0;\n    this.F = 0x68581511 | 0;\n    this.G = 0x64f98fa7 | 0;\n    this.H = 0xbefa4fa4 | 0;\n    this.outputLen = 28;\n  }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());\nexports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip39/node_modules/@noble/hashes/sha256.js?");

/***/ }),

/***/ "./node_modules/@scure/bip39/node_modules/@noble/hashes/sha512.js":
/*!************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/sha512.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;\nconst _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/_sha2.js\");\nconst _u64_js_1 = __webpack_require__(/*! ./_u64.js */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/_u64.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/utils.js\");\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = _u64_js_1.default.split(['0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc', '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118', '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2', '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694', '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65', '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5', '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4', '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70', '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df', '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b', '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30', '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8', '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8', '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3', '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec', '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b', '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178', '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b', '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c', '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'].map(n => BigInt(n)));\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = new Uint32Array(80);\nconst SHA512_W_L = new Uint32Array(80);\nclass SHA512 extends _sha2_js_1.SHA2 {\n  constructor() {\n    super(128, 64, 16, false);\n    // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n    // Also looks cleaner and easier to verify with spec.\n    // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n    // h -- high 32 bits, l -- low 32 bits\n    this.Ah = 0x6a09e667 | 0;\n    this.Al = 0xf3bcc908 | 0;\n    this.Bh = 0xbb67ae85 | 0;\n    this.Bl = 0x84caa73b | 0;\n    this.Ch = 0x3c6ef372 | 0;\n    this.Cl = 0xfe94f82b | 0;\n    this.Dh = 0xa54ff53a | 0;\n    this.Dl = 0x5f1d36f1 | 0;\n    this.Eh = 0x510e527f | 0;\n    this.El = 0xade682d1 | 0;\n    this.Fh = 0x9b05688c | 0;\n    this.Fl = 0x2b3e6c1f | 0;\n    this.Gh = 0x1f83d9ab | 0;\n    this.Gl = 0xfb41bd6b | 0;\n    this.Hh = 0x5be0cd19 | 0;\n    this.Hl = 0x137e2179 | 0;\n  }\n  // prettier-ignore\n  get() {\n    const {\n      Ah,\n      Al,\n      Bh,\n      Bl,\n      Ch,\n      Cl,\n      Dh,\n      Dl,\n      Eh,\n      El,\n      Fh,\n      Fl,\n      Gh,\n      Gl,\n      Hh,\n      Hl\n    } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  process(view, offset) {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32(offset += 4);\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);\n      const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);\n      const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let {\n      Ah,\n      Al,\n      Bh,\n      Bl,\n      Ch,\n      Cl,\n      Dh,\n      Dl,\n      Eh,\n      El,\n      Fh,\n      Fl,\n      Gh,\n      Gl,\n      Hh,\n      Hl\n    } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);\n      const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = Eh & Fh ^ ~Eh & Gh;\n      const CHIl = El & Fl ^ ~El & Gl;\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);\n      const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);\n      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({\n        h: Eh,\n        l: El\n      } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);\n      Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({\n      h: Ah,\n      l: Al\n    } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({\n      h: Bh,\n      l: Bl\n    } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({\n      h: Ch,\n      l: Cl\n    } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({\n      h: Dh,\n      l: Dl\n    } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({\n      h: Eh,\n      l: El\n    } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({\n      h: Fh,\n      l: Fl\n    } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({\n      h: Gh,\n      l: Gl\n    } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({\n      h: Hh,\n      l: Hl\n    } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  roundClean() {\n    SHA512_W_H.fill(0);\n    SHA512_W_L.fill(0);\n  }\n  destroy() {\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\nexports.SHA512 = SHA512;\nclass SHA512_224 extends SHA512 {\n  constructor() {\n    super();\n    // h -- high 32 bits, l -- low 32 bits\n    this.Ah = 0x8c3d37c8 | 0;\n    this.Al = 0x19544da2 | 0;\n    this.Bh = 0x73e19966 | 0;\n    this.Bl = 0x89dcd4d6 | 0;\n    this.Ch = 0x1dfab7ae | 0;\n    this.Cl = 0x32ff9c82 | 0;\n    this.Dh = 0x679dd514 | 0;\n    this.Dl = 0x582f9fcf | 0;\n    this.Eh = 0x0f6d2b69 | 0;\n    this.El = 0x7bd44da8 | 0;\n    this.Fh = 0x77e36f73 | 0;\n    this.Fl = 0x04c48942 | 0;\n    this.Gh = 0x3f9d85a8 | 0;\n    this.Gl = 0x6a1d36c8 | 0;\n    this.Hh = 0x1112e6ad | 0;\n    this.Hl = 0x91d692a1 | 0;\n    this.outputLen = 28;\n  }\n}\nclass SHA512_256 extends SHA512 {\n  constructor() {\n    super();\n    // h -- high 32 bits, l -- low 32 bits\n    this.Ah = 0x22312194 | 0;\n    this.Al = 0xfc2bf72c | 0;\n    this.Bh = 0x9f555fa3 | 0;\n    this.Bl = 0xc84c64c2 | 0;\n    this.Ch = 0x2393b86b | 0;\n    this.Cl = 0x6f53b151 | 0;\n    this.Dh = 0x96387719 | 0;\n    this.Dl = 0x5940eabd | 0;\n    this.Eh = 0x96283ee2 | 0;\n    this.El = 0xa88effe3 | 0;\n    this.Fh = 0xbe5e1e25 | 0;\n    this.Fl = 0x53863992 | 0;\n    this.Gh = 0x2b0199fc | 0;\n    this.Gl = 0x2c85b8aa | 0;\n    this.Hh = 0x0eb72ddc | 0;\n    this.Hl = 0x81c52ca2 | 0;\n    this.outputLen = 32;\n  }\n}\nclass SHA384 extends SHA512 {\n  constructor() {\n    super();\n    // h -- high 32 bits, l -- low 32 bits\n    this.Ah = 0xcbbb9d5d | 0;\n    this.Al = 0xc1059ed8 | 0;\n    this.Bh = 0x629a292a | 0;\n    this.Bl = 0x367cd507 | 0;\n    this.Ch = 0x9159015a | 0;\n    this.Cl = 0x3070dd17 | 0;\n    this.Dh = 0x152fecd8 | 0;\n    this.Dl = 0xf70e5939 | 0;\n    this.Eh = 0x67332667 | 0;\n    this.El = 0xffc00b31 | 0;\n    this.Fh = 0x8eb44a87 | 0;\n    this.Fl = 0x68581511 | 0;\n    this.Gh = 0xdb0c2e0d | 0;\n    this.Gl = 0x64f98fa7 | 0;\n    this.Hh = 0x47b5481d | 0;\n    this.Hl = 0xbefa4fa4 | 0;\n    this.outputLen = 48;\n  }\n}\nexports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());\nexports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());\nexports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());\nexports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip39/node_modules/@noble/hashes/sha512.js?");

/***/ }),

/***/ "./node_modules/@scure/bip39/node_modules/@noble/hashes/utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"./node_modules/@scure/bip39/node_modules/@noble/hashes/cryptoBrowser.js\");\n// Cast array to different type\nconst u8 = arr => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => word << 32 - shift | word >>> shift;\nexports.rotr = rotr;\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.\n// So, just to be sure not to corrupt anything.\nif (!exports.isLE) throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\nfunction bytesToHex(uint8a) {\n  // pre-caching improves the speed 6x\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  let hex = '';\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n  return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('deadbeef')\n */\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  const array = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise\n// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => {};\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await (0, exports.nextTick)();\n    ts += diff;\n  }\n}\nexports.asyncLoop = asyncLoop;\nfunction utf8ToBytes(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n  }\n  return new TextEncoder().encode(str);\n}\nexports.utf8ToBytes = utf8ToBytes;\nfunction toBytes(data) {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!(data instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n  return data;\n}\nexports.toBytes = toBytes;\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nfunction concatBytes(...arrays) {\n  if (!arrays.every(a => a instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n  // Safe version that clones internal state\n  clone() {\n    return this._cloneInto();\n  }\n}\nexports.Hash = Hash;\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = obj => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n  if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts))) throw new TypeError('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashConstructor) {\n  const hashC = message => hashConstructor().update(toBytes(message)).digest();\n  const tmp = hashConstructor();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashConstructor();\n  return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({});\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = opts => hashCons(opts);\n  return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\n/**\n * Secure PRNG\n */\nfunction randomBytes(bytesLength = 32) {\n  if (crypto_1.crypto.web) {\n    return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));\n  } else if (crypto_1.crypto.node) {\n    return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);\n  } else {\n    throw new Error(\"The environment doesn't have randomBytes function\");\n  }\n}\nexports.randomBytes = randomBytes;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip39/node_modules/@noble/hashes/utils.js?");

/***/ }),

/***/ "./node_modules/@scure/bip39/wordlists/english.js":
/*!********************************************************!*\
  !*** ./node_modules/@scure/bip39/wordlists/english.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.wordlist = void 0;\nexports.wordlist = `abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo`.split('\\n');\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip39/wordlists/english.js?");

/***/ }),

/***/ "./node_modules/PubSub/dist/PubSub.esm.min.js":
/*!****************************************************!*\
  !*** ./node_modules/PubSub/dist/PubSub.esm.min.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * PubSub\n * Javascript implementation of the Publish/Subscribe pattern.\n *\n * @version v4.0.0\n * @author George Raptis <georapbox@gmail.com>\n * @homepage https://github.com/georapbox/PubSub#readme\n * @repository https://github.com/georapbox/PubSub.git\n * @license MIT\n */\nfunction t(t, e) {\n  for (var r = 0; r < e.length; r++) {\n    var n = e[r];\n    n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n  }\n}\nfunction e(t, e, r) {\n  return e in t ? Object.defineProperty(t, e, {\n    value: r,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : t[e] = r, t;\n}\nfunction r(t, e) {\n  var r = Object.keys(t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(t);\n    e && (n = n.filter(function (e) {\n      return Object.getOwnPropertyDescriptor(t, e).enumerable;\n    })), r.push.apply(r, n);\n  }\n  return r;\n}\nfunction n(t) {\n  for (var n = 1; n < arguments.length; n++) {\n    var o = null != arguments[n] ? arguments[n] : {};\n    n % 2 ? r(Object(o), !0).forEach(function (r) {\n      e(t, r, o[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(o)) : r(Object(o)).forEach(function (e) {\n      Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(o, e));\n    });\n  }\n  return t;\n}\nfunction o(t) {\n  return function (t) {\n    if (Array.isArray(t)) return i(t);\n  }(t) || function (t) {\n    if (\"undefined\" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t);\n  }(t) || function (t, e) {\n    if (!t) return;\n    if (\"string\" == typeof t) return i(t, e);\n    var r = Object.prototype.toString.call(t).slice(8, -1);\n    \"Object\" === r && t.constructor && (r = t.constructor.name);\n    if (\"Map\" === r || \"Set\" === r) return Array.from(t);\n    if (\"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return i(t, e);\n  }(t) || function () {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }();\n}\nfunction i(t, e) {\n  (null == e || e > t.length) && (e = t.length);\n  for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];\n  return n;\n}\nvar u = function (t, e, r) {\n    for (var n in t) if (Object.prototype.hasOwnProperty.call(t, n) && e && !1 === e.call(r, t[n], n, t)) return;\n    return t;\n  },\n  c = function (t, e, r) {\n    for (var n = r._pubsub_topics, i = n[t] ? o(n[t]) : [], u = 0, c = i.length; u < c; u += 1) {\n      var a = i[u].token,\n        s = i[u];\n      if (r._options.immediateExceptions) s.callback(e, {\n        name: t,\n        token: a\n      });else try {\n        s.callback(e, {\n          name: t,\n          token: a\n        });\n      } catch (t) {\n        setTimeout(function () {\n          throw t;\n        }, 0);\n      }\n      !0 === s.once && r.unsubscribe(a);\n    }\n  },\n  a = function (t) {\n    for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) r[n - 1] = arguments[n];\n    return r.length <= 1 ? r[0] : [].concat(r);\n  },\n  s = function (t, e, r, n) {\n    return !!t._pubsub_topics[e] && (n ? c(e, r, t) : setTimeout(function () {\n      c(e, r, t);\n    }, 0), !0);\n  },\n  b = function () {\n    function e(t) {\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e);\n      this._pubsub_topics = {}, this._pubsub_uid = -1, this._options = n(n({}, {\n        immediateExceptions: !1\n      }), t);\n    }\n    var r, i, c;\n    return r = e, (i = [{\n      key: \"subscribe\",\n      value: function (t, e, r) {\n        var n = this._pubsub_topics,\n          o = this._pubsub_uid += 1,\n          i = {};\n        if (\"function\" != typeof e) throw new TypeError(\"When subscribing for an event, a callback function must be defined.\");\n        return n[t] || (n[t] = []), i.token = o, i.callback = e, i.once = !!r, n[t].push(i), o;\n      }\n    }, {\n      key: \"subscribeOnce\",\n      value: function (t, e) {\n        return this.subscribe(t, e, !0);\n      }\n    }, {\n      key: \"publish\",\n      value: function (t) {\n        for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) r[n - 1] = arguments[n];\n        return s(this, t, a.apply(void 0, [t].concat(r)), !1);\n      }\n    }, {\n      key: \"publishSync\",\n      value: function (t) {\n        for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) r[n - 1] = arguments[n];\n        return s(this, t, a.apply(void 0, [t].concat(r)), !0);\n      }\n    }, {\n      key: \"unsubscribe\",\n      value: function (t) {\n        var e = this._pubsub_topics,\n          r = !1;\n        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n) && e[n]) {\n          for (var o = e[n].length; o;) {\n            if (o -= 1, e[n][o].token === t) return e[n].splice(o, 1), 0 === e[n].length && delete e[n], t;\n            n === t && (e[n].splice(o, 1), 0 === e[n].length && delete e[n], r = !0);\n          }\n          if (!0 === r) return t;\n        }\n        return !1;\n      }\n    }, {\n      key: \"unsubscribeAll\",\n      value: function () {\n        return this._pubsub_topics = {}, this;\n      }\n    }, {\n      key: \"hasSubscribers\",\n      value: function (t) {\n        var e = this._pubsub_topics,\n          r = !1;\n        return null == t ? (u(e, function (t, e) {\n          if (e) return r = !0, !1;\n        }), r) : Object.prototype.hasOwnProperty.call(e, t);\n      }\n    }, {\n      key: \"subscribers\",\n      value: function () {\n        var t = {};\n        return u(this._pubsub_topics, function (e, r) {\n          t[r] = o(e);\n        }), t;\n      }\n    }, {\n      key: \"subscribersByTopic\",\n      value: function (t) {\n        return this._pubsub_topics[t] ? o(this._pubsub_topics[t]) : [];\n      }\n    }, {\n      key: \"alias\",\n      value: function (t) {\n        var r = this;\n        return u(t, function (n, o) {\n          var i, u;\n          e.prototype[o] && (e.prototype[t[o]] = (i = o, u = r, function () {\n            for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];\n            return u[i].apply(u, e);\n          }));\n        }), this;\n      }\n    }]) && t(r.prototype, i), c && t(r, c), e;\n  }();\nb.createInstance = function (t) {\n  return new b(t);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (b);\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/PubSub/dist/PubSub.esm.min.js?");

/***/ }),

/***/ "./src/app/test.js":
/*!*************************!*\
  !*** ./src/app/test.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nostr-tools */ \"./node_modules/nostr-tools/lib/esm/nostr.mjs\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\nvar PubSub = (__webpack_require__(/*! PubSub */ \"./node_modules/PubSub/dist/PubSub.esm.min.js\")[\"default\"]);\nvar pubsub = new PubSub();\nwindow.pop = function () {\n  console.log(1);\n};\nvar state = {\n  note: \"This is my prefilled note\",\n  publish: function publish(event) {\n    var pub = relay.publish(event);\n    pub.on('ok', function () {\n      console.log(\"\".concat(relay.url, \" has accepted our event\"));\n    });\n    pub.on('failed', function (reason) {\n      console.log(\"failed to publish to \".concat(relay.url, \": \").concat(reason));\n    });\n  },\n  submitNote: function submitNote() {\n    var pass = JSON.parse(localStorage.getItem('nostrpass'));\n    var event = {\n      kind: 1,\n      pubkey: pass.pk,\n      created_at: Math.floor(Date.now() / 1000),\n      tags: [],\n      content: state.note\n    };\n    event.id = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_0__.getEventHash)(event);\n    //event.sig = signEvent(event, sk)\n\n    ifrm.contentWindow.postMessage({\n      method: \"get-sig\",\n      data: event,\n      cb: 'publish'\n    }, \"*\");\n  }\n};\nvar testModule = {\n  oninit: function () {\n    var _oninit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var onUserAdd;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            window.relay = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_0__.relayInit)('wss://relay.damus.io');\n            relay.on('connect', function () {\n              console.log(\"connected to \".concat(relay.url));\n            });\n            relay.on('error', function () {\n              console.log(\"failed to connect to \".concat(relay.url));\n            });\n            _context.next = 5;\n            return relay.connect();\n          case 5:\n            onUserAdd = pubsub.subscribe('got-signature', function (data, topic) {\n              console.log(data);\n              state.publish(data);\n            });\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    function oninit() {\n      return _oninit.apply(this, arguments);\n    }\n    return oninit;\n  }(),\n  view: function view() {\n    return [m('.current', 'Current User npub: ', state.current), m('.noteTaker', m('textarea.note', {\n      oninput: function oninput(e) {\n        state.note = e.target.value;\n      }\n    }, state.note)), m(\"button\", {\n      onclick: state.submitNote\n    }, \"Submit Note\")];\n  }\n};\nwindow.addEventListener(\"message\", function (event) {\n  console.log(event.data);\n  /* console.log(event.source,ifrm.contentWindow)\n   if (event.source !== ifrm.contentWindow) return;*/\n\n  if (event.data.sig) {\n    pubsub.publish('got-signature', event.data.event);\n  }\n  if (event.data.redirect) {\n    window.location = event.data.redirect;\n  }\n  if (event.data.token && !localStorage.getItem('nostrpass') || event.data.connected) {\n    localStorage.setItem('nostrpass', JSON.stringify(event.data));\n    button.style.display = \"none\";\n  }\n  if (event.data.connected === false) {\n    window.location = bridgeUrl;\n  } else if (localStorage.getItem('nostrpass')) {\n    button.style.display = \"none\";\n  }\n  if (event.data.method == 'get-sig') {}\n}, false);\nm.mount(document.querySelector('.main'), testModule);\n\n//# sourceURL=webpack://my-webpack-project/./src/app/test.js?");

/***/ }),

/***/ "?ce41":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://my-webpack-project/crypto_(ignored)?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createCurve\": () => (/* binding */ createCurve),\n/* harmony export */   \"getHash\": () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n  return {\n    hash,\n    hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes\n  };\n}\nfunction createCurve(curveDef, defHash) {\n  const create = hash => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({\n    ...curveDef,\n    ...getHash(hash)\n  });\n  return Object.freeze({\n    ...create(defHash),\n    create\n  });\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/curves/esm/_shortw_utils.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"validateBasic\": () => (/* binding */ validateBasic),\n/* harmony export */   \"wNAF\": () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n  const constTimeNegate = (condition, item) => {\n    const neg = item.negate();\n    return condition ? neg : item;\n  };\n  const opts = W => {\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return {\n      windows,\n      windowSize\n    };\n  };\n  return {\n    constTimeNegate,\n    // non-const time multiplication ladder\n    unsafeLadder(elm, n) {\n      let p = c.ZERO;\n      let d = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n     * - 𝑊 is the window size\n     * - 𝑛 is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm, W) {\n      const {\n        windows,\n        windowSize\n      } = opts(W);\n      const points = [];\n      let p = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W, precomputes, n) {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      const {\n        windows,\n        windowSize\n      } = opts(W);\n      let p = c.ZERO;\n      let f = c.BASE;\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        // Extract W bits.\n        let wbits = Number(n & mask);\n        // Shift number by W bits.\n        n >>= shiftBy;\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return {\n        p,\n        f\n      };\n    },\n    wNAFCached(P, precomputesMap, n, transform) {\n      // @ts-ignore\n      const W = P._WINDOW_SIZE || 1;\n      // Calculate precomputes on a first run, reuse them after\n      let comp = precomputesMap.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W);\n        if (W !== 1) {\n          precomputesMap.set(P, transform(comp));\n        }\n      }\n      return this.wNAF(W, comp, n);\n    }\n  };\n}\nfunction validateBasic(curve) {\n  (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n    n: 'bigint',\n    h: 'bigint',\n    Gx: 'field',\n    Gy: 'field'\n  }, {\n    nBitLength: 'isSafeInteger',\n    nByteLength: 'isSafeInteger'\n  });\n  // Set defaults\n  return Object.freeze({\n    ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n    ...curve\n  });\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/curves/esm/abstract/curve.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createHasher\": () => (/* binding */ createHasher),\n/* harmony export */   \"expand_message_xmd\": () => (/* binding */ expand_message_xmd),\n/* harmony export */   \"expand_message_xof\": () => (/* binding */ expand_message_xof),\n/* harmony export */   \"hash_to_field\": () => (/* binding */ hash_to_field),\n/* harmony export */   \"isogenyMap\": () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\nfunction validateDST(dst) {\n  if (dst instanceof Uint8Array) return dst;\n  if (typeof dst === 'string') return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(dst);\n  throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n  if (value < 0 || value >= 1 << 8 * length) {\n    throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n  }\n  const res = Array.from({\n    length\n  }).fill(0);\n  for (let i = length - 1; i >= 0; i--) {\n    res[i] = value & 0xff;\n    value >>>= 8;\n  }\n  return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n  const arr = new Uint8Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    arr[i] = a[i] ^ b[i];\n  }\n  return arr;\n}\nfunction isBytes(item) {\n  if (!(item instanceof Uint8Array)) throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.4.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n  isBytes(msg);\n  isBytes(DST);\n  isNum(lenInBytes);\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n  if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n  const {\n    outputLen: b_in_bytes,\n    blockLen: r_in_bytes\n  } = H;\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\n  if (ell > 255) throw new Error('Invalid xmd length');\n  const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(DST, i2osp(DST.length, 1));\n  const Z_pad = i2osp(0, r_in_bytes);\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n  const b = new Array(ell);\n  const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n  b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n  for (let i = 1; i <= ell; i++) {\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n    b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...args));\n  }\n  const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...b);\n  return pseudo_random_bytes.slice(0, lenInBytes);\n}\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n  isBytes(msg);\n  isBytes(DST);\n  isNum(lenInBytes);\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n  if (DST.length > 255) {\n    const dkLen = Math.ceil(2 * k / 8);\n    DST = H.create({\n      dkLen\n    }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n  }\n  if (lenInBytes > 65535 || DST.length > 255) throw new Error('expand_message_xof: invalid lenInBytes');\n  return H.create({\n    dkLen: lenInBytes\n  }).update(msg).update(i2osp(lenInBytes, 2))\n  // 2. DST_prime = DST || I2OSP(len(DST), 1)\n  .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.3\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(options, {\n    DST: 'string',\n    p: 'bigint',\n    m: 'isSafeInteger',\n    k: 'isSafeInteger',\n    hash: 'hash'\n  });\n  const {\n    p,\n    k,\n    m,\n    hash,\n    expand,\n    DST: _DST\n  } = options;\n  isBytes(msg);\n  isNum(count);\n  const DST = validateDST(_DST);\n  const log2p = p.toString(2).length;\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n  const len_in_bytes = count * m * L;\n  let prb; // pseudo_random_bytes\n  if (expand === 'xmd') {\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n  } else if (expand === 'xof') {\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n  } else if (expand === undefined) {\n    prb = msg;\n  } else {\n    throw new Error('expand must be \"xmd\", \"xof\" or undefined');\n  }\n  const u = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const e = new Array(m);\n    for (let j = 0; j < m; j++) {\n      const elm_offset = L * (j + i * m);\n      const tv = prb.subarray(elm_offset, elm_offset + L);\n      e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(os2ip(tv), p);\n    }\n    u[i] = e;\n  }\n  return u;\n}\nfunction isogenyMap(field, map) {\n  // Make same order as in spec\n  const COEFF = map.map(i => Array.from(i).reverse());\n  return (x, y) => {\n    const [xNum, xDen, yNum, yDen] = COEFF.map(val => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n    x = field.div(xNum, xDen); // xNum / xDen\n    y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n    return {\n      x,\n      y\n    };\n  };\n}\nfunction createHasher(Point, mapToCurve, def) {\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n  return {\n    // Encodes byte string to elliptic curve\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n    hashToCurve(msg, options) {\n      const u = hash_to_field(msg, 2, {\n        ...def,\n        DST: def.DST,\n        ...options\n      });\n      const u0 = Point.fromAffine(mapToCurve(u[0]));\n      const u1 = Point.fromAffine(mapToCurve(u[1]));\n      const P = u0.add(u1).clearCofactor();\n      P.assertValidity();\n      return P;\n    },\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n    encodeToCurve(msg, options) {\n      const u = hash_to_field(msg, 1, {\n        ...def,\n        DST: def.encodeDST,\n        ...options\n      });\n      const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n      P.assertValidity();\n      return P;\n    }\n  };\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Fp\": () => (/* binding */ Fp),\n/* harmony export */   \"FpDiv\": () => (/* binding */ FpDiv),\n/* harmony export */   \"FpInvertBatch\": () => (/* binding */ FpInvertBatch),\n/* harmony export */   \"FpIsSquare\": () => (/* binding */ FpIsSquare),\n/* harmony export */   \"FpPow\": () => (/* binding */ FpPow),\n/* harmony export */   \"FpSqrt\": () => (/* binding */ FpSqrt),\n/* harmony export */   \"FpSqrtEven\": () => (/* binding */ FpSqrtEven),\n/* harmony export */   \"FpSqrtOdd\": () => (/* binding */ FpSqrtOdd),\n/* harmony export */   \"hashToPrivateScalar\": () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   \"invert\": () => (/* binding */ invert),\n/* harmony export */   \"isNegativeLE\": () => (/* binding */ isNegativeLE),\n/* harmony export */   \"mod\": () => (/* binding */ mod),\n/* harmony export */   \"nLength\": () => (/* binding */ nLength),\n/* harmony export */   \"pow\": () => (/* binding */ pow),\n/* harmony export */   \"pow2\": () => (/* binding */ pow2),\n/* harmony export */   \"tonelliShanks\": () => (/* binding */ tonelliShanks),\n/* harmony export */   \"validateField\": () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4),\n  _5n = BigInt(5),\n  _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9),\n  _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently exponentiate num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * powMod(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n  if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = res * num % modulo;\n    num = num * num % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n  // Eucledian GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n,\n    y = _1n,\n    u = _1n,\n    v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n// Tonelli-Shanks algorithm\n// Paper 1: https://eprint.iacr.org/2012/685.pdf (page 12)\n// Paper 2: Square Roots from 1; 24, 51, 10 to Dan Shanks\nfunction tonelliShanks(P) {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p) ≡ 1    if a is a square (mod p)\n  // (a | p) ≡ -1   if a is not a square (mod p)\n  // (a | p) ≡ 0    if a ≡ 0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n  let Q, S, Z;\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n  // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast(Fp, n) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow(Fp, n) {\n    // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: will fail at Fp2/etc\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\nfunction FpSqrt(P) {\n  // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n  // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n  // P ≡ 3 (mod 4)\n  // √n = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4(Fp, n) {\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n  // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8(Fp, n) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n  // P ≡ 9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = ['create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr', 'eql', 'add', 'sub', 'mul', 'pow', 'div', 'addN', 'subN', 'mulN', 'sqrN'];\nfunction validateField(field) {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger'\n  };\n  const opts = FIELD_FIELDS.reduce((map, val) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\nfunction FpPow(f, num, power) {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('Expected power > 0');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= 1n;\n  }\n  return p;\n}\nfunction FpInvertBatch(f, nums) {\n  const tmp = new Array(nums.length);\n  // Walk from first to last, multiply them by each other MOD p\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE);\n  // Invert last element\n  const inverted = f.inv(lastMultiplied);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n  const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n  return x => {\n    const p = f.pow(x, legendreConst);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return {\n    nBitLength: _nBitLength,\n    nByteLength\n  };\n}\nfunction Fp(ORDER, bitLen, isLE = false, redef = {}) {\n  if (ORDER <= _0n) throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);\n  const {\n    nBitLength: BITS,\n    nByteLength: BYTES\n  } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');\n  const sqrtP = FpSqrt(ORDER);\n  const f = Object.freeze({\n    ORDER,\n    BITS,\n    BYTES,\n    MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: num => mod(num, ORDER),\n    isValid: num => {\n      if (typeof num !== 'bigint') throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n\n    is0: num => num === _0n,\n    isOdd: num => (num & _1n) === _1n,\n    neg: num => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n    sqr: num => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n    // Same as above, but doesn't normalize\n    sqrN: num => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n    inv: num => invert(num, ORDER),\n    sqrt: redef.sqrt || (n => sqrtP(f, n)),\n    invertBatch: lst => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => c ? b : a,\n    toBytes: num => isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n    fromBytes: bytes => {\n      if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n      return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n    }\n  });\n  return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * FIPS 186 B.4.1-compliant \"constant-time\" private key generation utility.\n * Can take (n+8) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being neglible.\n * Needs at least 40 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * @param hash hash output from SHA3 or a similar function\n * @returns valid private scalar\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n  hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n  const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/curves/esm/abstract/modular.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bitGet\": () => (/* binding */ bitGet),\n/* harmony export */   \"bitLen\": () => (/* binding */ bitLen),\n/* harmony export */   \"bitMask\": () => (/* binding */ bitMask),\n/* harmony export */   \"bitSet\": () => (/* binding */ bitSet),\n/* harmony export */   \"bytesToHex\": () => (/* binding */ bytesToHex),\n/* harmony export */   \"bytesToNumberBE\": () => (/* binding */ bytesToNumberBE),\n/* harmony export */   \"bytesToNumberLE\": () => (/* binding */ bytesToNumberLE),\n/* harmony export */   \"concatBytes\": () => (/* binding */ concatBytes),\n/* harmony export */   \"createHmacDrbg\": () => (/* binding */ createHmacDrbg),\n/* harmony export */   \"ensureBytes\": () => (/* binding */ ensureBytes),\n/* harmony export */   \"equalBytes\": () => (/* binding */ equalBytes),\n/* harmony export */   \"hexToBytes\": () => (/* binding */ hexToBytes),\n/* harmony export */   \"hexToNumber\": () => (/* binding */ hexToNumber),\n/* harmony export */   \"numberToBytesBE\": () => (/* binding */ numberToBytesBE),\n/* harmony export */   \"numberToBytesLE\": () => (/* binding */ numberToBytesLE),\n/* harmony export */   \"numberToHexUnpadded\": () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   \"numberToVarBytesBE\": () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   \"utf8ToBytes\": () => (/* binding */ utf8ToBytes),\n/* harmony export */   \"validateObject\": () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = a => a instanceof Uint8Array;\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(bytes) {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\nfunction numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// Caching slows it down 2-3x\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  if (hex.length % 2) throw new Error('hex string is invalid: unpadded ' + hex.length);\n  const array = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n// Big Endian\nfunction bytesToNumberBE(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nconst numberToBytesBE = (n, len) => hexToBytes(n.toString(16).padStart(len * 2, '0'));\nconst numberToBytesLE = (n, len) => numberToBytesBE(n, len).reverse();\n// Returns variable number bytes (minimal bigint encoding?)\nconst numberToVarBytesBE = n => hexToBytes(numberToHexUnpadded(n));\nfunction ensureBytes(title, hex, expectedLength) {\n  let res;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n  } else if (u8a(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(`${title} must be hex string or Uint8Array`);\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n  return res;\n}\n// Copies several Uint8Arrays into one.\nfunction concatBytes(...arrs) {\n  const r = new Uint8Array(arrs.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrs.forEach(a => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\nfunction equalBytes(b1, b2) {\n  // We don't care about timing attacks here\n  if (b1.length !== b2.length) return false;\n  for (let i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;\n  return true;\n}\nfunction utf8ToBytes(str) {\n  if (typeof str !== 'string') {\n    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  }\n  return new TextEncoder().encode(str);\n}\n// Bit operations\n// Amount of bits inside bigint (Same as n.toString(2).length)\nfunction bitLen(n) {\n  let len;\n  for (len = 0; n > 0n; n >>= _1n, len += 1);\n  return len;\n}\n// Gets single bit at position. NOTE: first bit position is 0 (same as arrays)\n// Same as !!+Array.from(n.toString(2)).reverse()[pos]\nconst bitGet = (n, pos) => n >> BigInt(pos) & 1n;\n// Sets single bit at position\nconst bitSet = (n, pos, value) => n | (value ? _1n : _0n) << BigInt(pos);\n// Return mask for N bits (Same as BigInt(`0b${Array(i).fill('1').join('')}`))\n// Not using ** operator with bigints for old engines.\nconst bitMask = n => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = data => new Uint8Array(data); // creates Uint8Array\nconst u8fr = arr => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed, pred) => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n  bigint: val => typeof val === 'bigint',\n  function: val => typeof val === 'function',\n  boolean: val => typeof val === 'boolean',\n  string: val => typeof val === 'string',\n  isSafeInteger: val => Number.isSafeInteger(val),\n  array: val => Array.isArray(val),\n  field: (val, object) => object.Fp.isValid(val),\n  hash: val => typeof val === 'function' && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n  const checkField = (fieldName, type, isOptional) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error(`Invalid validator \"${type}\", expected function`);\n    const val = object[fieldName];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/curves/esm/abstract/utils.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SWUFpSqrtRatio\": () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   \"mapToCurveSimpleSWU\": () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   \"weierstrass\": () => (/* binding */ weierstrass),\n/* harmony export */   \"weierstrassPoints\": () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curve.js */ \"./node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n  const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_2__.validateBasic)(curve);\n  _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n    a: 'field',\n    b: 'field',\n    fromBytes: 'function',\n    toBytes: 'function'\n  }, {\n    allowedPrivateKeyLengths: 'array',\n    wrapPrivateKey: 'boolean',\n    isTorsionFree: 'function',\n    clearCofactor: 'function',\n    allowInfinityPoint: 'boolean'\n  });\n  const {\n    endo,\n    Fp,\n    a\n  } = opts;\n  if (endo) {\n    if (!Fp.eql(a, Fp.ZERO)) {\n      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n    }\n    if (typeof endo !== 'object' || typeof endo.beta !== 'bigint' || typeof endo.splitScalar !== 'function') {\n      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n    }\n  }\n  return Object.freeze({\n    ...opts\n  });\n}\n// ASN.1 DER encoding utilities\nconst {\n  bytesToNumberBE: b2n,\n  hexToBytes: h2b\n} = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n  // asn.1 DER encoding utils\n  Err: class DERErr extends Error {\n    constructor(m = '') {\n      super(m);\n    }\n  },\n  _parseInt(data) {\n    const {\n      Err: E\n    } = DER;\n    if (data.length < 2 || data[0] !== 0x02) throw new E('Invalid signature integer tag');\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) throw new E('Invalid signature integer: wrong length');\n    if (res[0] === 0x00 && res[1] <= 0x7f) throw new E('Invalid signature integer: trailing length');\n    // ^ Weird condition: not about length, but about first bytes of number.\n    return {\n      d: b2n(res),\n      l: data.subarray(len + 2)\n    }; // d is data, l is left\n  },\n\n  toSig(hex) {\n    // parse DER signature\n    const {\n      Err: E\n    } = DER;\n    const data = typeof hex === 'string' ? h2b(hex) : hex;\n    if (!(data instanceof Uint8Array)) throw new Error('ui8a expected');\n    let l = data.length;\n    if (l < 2 || data[0] != 0x30) throw new E('Invalid signature tag');\n    if (data[1] !== l - 2) throw new E('Invalid signature: incorrect length');\n    const {\n      d: r,\n      l: sBytes\n    } = DER._parseInt(data.subarray(2));\n    const {\n      d: s,\n      l: rBytesLeft\n    } = DER._parseInt(sBytes);\n    if (rBytesLeft.length) throw new E('Invalid signature: left bytes after parsing');\n    return {\n      r,\n      s\n    };\n  },\n  hexFromSig(sig) {\n    const slice = s => Number.parseInt(s[0], 16) >= 8 ? '00' + s : s; // slice DER\n    const h = num => {\n      const hex = num.toString(16);\n      return hex.length & 1 ? `0${hex}` : hex;\n    };\n    const s = slice(h(sig.s));\n    const r = slice(h(sig.r));\n    const shl = s.length / 2;\n    const rhl = r.length / 2;\n    const sl = h(shl);\n    const rl = h(rhl);\n    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n  }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals like 123n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction weierstrassPoints(opts) {\n  const CURVE = validatePointOpts(opts);\n  const {\n    Fp\n  } = CURVE; // All curves has same field / group length as for now, but they can differ\n  /**\n   * y² = x³ + ax + b: Short weierstrass curve formula\n   * @returns y²\n   */\n  function weierstrassEquation(x) {\n    const {\n      a,\n      b\n    } = CURVE;\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n  }\n  // Valid group elements reside in range 1..n-1\n  function isWithinCurveOrder(num) {\n    return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n  }\n  function assertGE(num) {\n    if (!isWithinCurveOrder(num)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n  }\n  // Validates if priv key is valid and converts it to bigint.\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n  function normPrivateKeyToScalar(key) {\n    const {\n      allowedPrivateKeyLengths: lengths,\n      nByteLength,\n      wrapPrivateKey,\n      n\n    } = CURVE;\n    if (lengths && typeof key !== 'bigint') {\n      if (key instanceof Uint8Array) key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n      if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');\n      key = key.padStart(nByteLength * 2, '0');\n    }\n    let num;\n    try {\n      num = typeof key === 'bigint' ? key : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n    } catch (error) {\n      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n    }\n    if (wrapPrivateKey) num = _modular_js__WEBPACK_IMPORTED_MODULE_0__.mod(num, n); // disabled by default, enabled for BLS\n    assertGE(num); // num in range [1..N-1]\n    return num;\n  }\n  const pointPrecomputes = new Map();\n  function assertPrjPoint(other) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n   * Default Point works in 2d / affine coordinates: (x, y)\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point {\n    constructor(px, py, pz) {\n      this.px = px;\n      this.py = py;\n      this.pz = pz;\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\n      if (py == null || !Fp.isValid(py)) throw new Error('y required');\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n    }\n    // Does not validate if the point is on-curve.\n    // Use fromHex instead, or call assertValidity() later.\n    static fromAffine(p) {\n      const {\n        x,\n        y\n      } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      const is0 = i => Fp.eql(i, Fp.ZERO);\n      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n      if (is0(x) && is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    /**\n     * Takes a bunch of Projective Points but executes only one\n     * inversion on all of them. Inversion is very slow operation,\n     * so this improves performance massively.\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\n     */\n    static normalizeZ(points) {\n      const toInv = Fp.invertBatch(points.map(p => p.pz));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n    /**\n     * Converts hash string or Uint8Array to Point.\n     * @param hex short/long ECDSA hex\n     */\n    static fromHex(hex) {\n      const P = Point.fromAffine(CURVE.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    }\n    // Multiplies generator point by privateKey.\n    static fromPrivateKey(privateKey) {\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    }\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n    // A point on curve is valid if it conforms to equation.\n    assertValidity() {\n      // Zero is valid point too!\n      if (this.is0()) {\n        if (CURVE.allowInfinityPoint) return;\n        throw new Error('bad point: ZERO');\n      }\n      // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n      const {\n        x,\n        y\n      } = this.toAffine();\n      // Check if x, y are valid field elements\n      if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n      const left = Fp.sqr(y); // y²\n      const right = weierstrassEquation(x); // x³ + ax + b\n      if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\n      if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    }\n    hasEvenY() {\n      const {\n        y\n      } = this.toAffine();\n      if (Fp.isOdd) return !Fp.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n    /**\n     * Compare one point to another.\n     */\n    equals(other) {\n      assertPrjPoint(other);\n      const {\n        px: X1,\n        py: Y1,\n        pz: Z1\n      } = this;\n      const {\n        px: X2,\n        py: Y2,\n        pz: Z2\n      } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n    /**\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\n     */\n    negate() {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    }\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const {\n        a,\n        b\n      } = CURVE;\n      const b3 = Fp.mul(b, 3n);\n      const {\n        px: X1,\n        py: Y1,\n        pz: Z1\n      } = this;\n      let X3 = Fp.ZERO,\n        Y3 = Fp.ZERO,\n        Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other) {\n      assertPrjPoint(other);\n      const {\n        px: X1,\n        py: Y1,\n        pz: Z1\n      } = this;\n      const {\n        px: X2,\n        py: Y2,\n        pz: Z2\n      } = other;\n      let X3 = Fp.ZERO,\n        Y3 = Fp.ZERO,\n        Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, 3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n    subtract(other) {\n      return this.add(other.negate());\n    }\n    is0() {\n      return this.equals(Point.ZERO);\n    }\n    wNAF(n) {\n      return wnaf.wNAFCached(this, pointPrecomputes, n, comp => {\n        const toInv = Fp.invertBatch(comp.map(p => p.pz));\n        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n      });\n    }\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(n) {\n      const I = Point.ZERO;\n      if (n === _0n) return I;\n      assertGE(n); // Will throw on 0\n      if (n === _1n) return this;\n      const {\n        endo\n      } = CURVE;\n      if (!endo) return wnaf.unsafeLadder(this, n);\n      // Apply endomorphism\n      let {\n        k1neg,\n        k1,\n        k2neg,\n        k2\n      } = endo.splitScalar(n);\n      let k1p = I;\n      let k2p = I;\n      let d = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n      return k1p.add(k2p);\n    }\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar) {\n      assertGE(scalar);\n      let n = scalar;\n      let point, fake; // Fake point is used to const-time mult\n      const {\n        endo\n      } = CURVE;\n      if (endo) {\n        const {\n          k1neg,\n          k1,\n          k2neg,\n          k2\n        } = endo.splitScalar(n);\n        let {\n          p: k1p,\n          f: f1p\n        } = this.wNAF(k1);\n        let {\n          p: k2p,\n          f: f2p\n        } = this.wNAF(k2);\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        const {\n          p,\n          f\n        } = this.wNAF(n);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return Point.normalizeZ([point, fake])[0];\n    }\n    /**\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\n     * The trick could be useful if both P and Q are not G (not in our case).\n     * @returns non-zero affine point\n     */\n    multiplyAndAddUnsafe(Q, a, b) {\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n      const mul = (P, a // Select faster multiply() method\n      ) => a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n      const sum = mul(this, a).add(mul(Q, b));\n      return sum.is0() ? undefined : sum;\n    }\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n    toAffine(iz) {\n      const {\n        px: x,\n        py: y,\n        pz: z\n      } = this;\n      const is0 = this.is0();\n      // If invZ was 0, we return zero point. However we still want to execute\n      // all operations, so we replace invZ with a random number, 1.\n      if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n      const ax = Fp.mul(x, iz);\n      const ay = Fp.mul(y, iz);\n      const zz = Fp.mul(z, iz);\n      if (is0) return {\n        x: Fp.ZERO,\n        y: Fp.ZERO\n      };\n      if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n      return {\n        x: ax,\n        y: ay\n      };\n    }\n    isTorsionFree() {\n      const {\n        h: cofactor,\n        isTorsionFree\n      } = CURVE;\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n    }\n    clearCofactor() {\n      const {\n        h: cofactor,\n        clearCofactor\n      } = CURVE;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this);\n      return this.multiplyUnsafe(CURVE.h);\n    }\n    toRawBytes(isCompressed = true) {\n      this.assertValidity();\n      return CURVE.toBytes(Point, this, isCompressed);\n    }\n    toHex(isCompressed = true) {\n      return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n    }\n  }\n  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n  const _bits = CURVE.nBitLength;\n  const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_2__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n  return {\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder\n  };\n}\nfunction validateOpts(curve) {\n  const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_2__.validateBasic)(curve);\n  _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n    hash: 'hash',\n    hmac: 'function',\n    randomBytes: 'function'\n  }, {\n    bits2int: 'function',\n    bits2int_modN: 'function',\n    lowS: 'boolean'\n  });\n  return Object.freeze({\n    lowS: true,\n    ...opts\n  });\n}\nfunction weierstrass(curveDef) {\n  const CURVE = validateOpts(curveDef);\n  const CURVE_ORDER = CURVE.n;\n  const Fp = CURVE.Fp;\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n  function isValidFieldElement(num) {\n    return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n  }\n\n  function modN(a) {\n    return _modular_js__WEBPACK_IMPORTED_MODULE_0__.mod(a, CURVE_ORDER);\n  }\n  function invN(a) {\n    return _modular_js__WEBPACK_IMPORTED_MODULE_0__.invert(a, CURVE_ORDER);\n  }\n  const {\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder\n  } = weierstrassPoints({\n    ...CURVE,\n    toBytes(c, point, isCompressed) {\n      const a = point.toAffine();\n      const x = Fp.toBytes(a.x);\n      const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n      if (isCompressed) {\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n      } else {\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n      }\n    },\n    fromBytes(bytes) {\n      const len = bytes.length;\n      const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // this.assertValidity() is done inside of fromHex\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n        const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n        if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n        const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n        let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n        const isYOdd = (y & _1n) === _1n;\n        // ECDSA\n        const isHeadOdd = (head & 1) === 1;\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n        return {\n          x,\n          y\n        };\n      } else if (len === uncompressedLen && head === 0x04) {\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n          x,\n          y\n        };\n      } else {\n        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n      }\n    }\n  });\n  const numToNByteStr = num => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n  function isBiggerThanHalfOrder(number) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n  function normalizeS(s) {\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n  }\n  // slice bytes num\n  const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n  /**\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n   */\n  class Signature {\n    constructor(r, s, recovery) {\n      this.r = r;\n      this.s = s;\n      this.recovery = recovery;\n      this.assertValidity();\n    }\n    // pair (bytes of r, bytes of s)\n    static fromCompact(hex) {\n      const l = CURVE.nByteLength;\n      hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n    }\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(hex) {\n      const {\n        r,\n        s\n      } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n      return new Signature(r, s);\n    }\n    assertValidity() {\n      // can use assertGE here\n      if (!isWithinCurveOrder(this.r)) throw new Error('r must be 0 < r < CURVE.n');\n      if (!isWithinCurveOrder(this.s)) throw new Error('s must be 0 < s < CURVE.n');\n    }\n    addRecoveryBit(recovery) {\n      return new Signature(this.r, this.s, recovery);\n    }\n    recoverPublicKey(msgHash) {\n      const {\n        r,\n        s,\n        recovery: rec\n      } = this;\n      const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n      const prefix = (rec & 1) === 0 ? '02' : '03';\n      const R = Point.fromHex(prefix + numToNByteStr(radj));\n      const ir = invN(radj); // r^-1\n      const u1 = modN(-h * ir); // -hr^-1\n      const u2 = modN(s * ir); // sr^-1\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n      Q.assertValidity();\n      return Q;\n    }\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS() {\n      return isBiggerThanHalfOrder(this.s);\n    }\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n    }\n    // DER-encoded\n    toDERRawBytes() {\n      return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n      return DER.hexFromSig({\n        r: this.r,\n        s: this.s\n      });\n    }\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n      return numToNByteStr(this.r) + numToNByteStr(this.s);\n    }\n  }\n  const utils = {\n    isValidPrivateKey(privateKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n    /**\n     * Produces cryptographically secure private key from random of size (nBitLength+64)\n     * as per FIPS 186 B.4.1 with modulo bias being neglible.\n     */\n    randomPrivateKey: () => {\n      const rand = CURVE.randomBytes(Fp.BYTES + 8);\n      const num = _modular_js__WEBPACK_IMPORTED_MODULE_0__.hashToPrivateScalar(rand, CURVE_ORDER);\n      return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    },\n    /**\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n     * Allows to massively speed-up `point.multiply(scalar)`.\n     * @returns cached point\n     * @example\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n     * fast.multiply(privKey); // much faster ECDH now\n     */\n    precompute(windowSize = 8, point = Point.BASE) {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n      return point;\n    }\n  };\n  /**\n   * Computes public key for a private key. Checks for validity of the private key.\n   * @param privateKey private key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(privateKey, isCompressed = true) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n  }\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n    if (item instanceof Point) return true;\n    return false;\n  }\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from private key and public key.\n   * Checks: 1) private key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param privateA private key\n   * @param publicB different public key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(privateA, publicB, isCompressed = true) {\n    if (isProbPub(privateA)) throw new Error('first arg must be private key');\n    if (!isProbPub(publicB)) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n  }\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int = CURVE.bits2int || function (bytes) {\n    // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n    // for some cases, since bytes.length * 8 is not actual bitLength.\n    const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n    const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n    return delta > 0 ? num >> BigInt(delta) : num;\n  };\n  const bits2int_modN = CURVE.bits2int_modN || function (bytes) {\n    return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n  };\n  // NOTE: pads output with zero as per spec\n  const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n  /**\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n   */\n  function int2octets(num) {\n    if (typeof num !== 'bigint') throw new Error('bigint expected');\n    if (!(_0n <= num && num < ORDER_MASK)) throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n    // works with order, can have different size than numToField!\n    return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n  }\n  // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n  // Also it can be bigger for P224 + SHA256\n  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n    if (['recovered', 'canonical'].some(k => k in opts)) throw new Error('sign() legacy options not supported');\n    const {\n      hash,\n      randomBytes\n    } = CURVE;\n    let {\n      lowS,\n      prehash,\n      extraEntropy: ent\n    } = opts; // generates low-s sigs by default\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n    msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n    if (prehash) msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (ent != null) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n      seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e, Fp.BYTES)); // check for being of size BYTES\n    }\n\n    const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    function k2sig(kBytes) {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n      const ik = invN(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n      const r = modN(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n\n      return new Signature(r, normS, recovery); // use normS, not s\n    }\n\n    return {\n      seed,\n      k2sig\n    };\n  }\n  const defaultSigOpts = {\n    lowS: CURVE.lowS,\n    prehash: false\n  };\n  const defaultVerOpts = {\n    lowS: CURVE.lowS,\n    prehash: false\n  };\n  /**\n   * Signs message hash (not message: you need to hash it by yourself).\n   * ```\n   * sign(m, d, k) where\n   *   (x, y) = G × k\n   *   r = x mod n\n   *   s = (m + dr)/k mod n\n   * ```\n   * @param opts `lowS, extraEntropy, prehash`\n   */\n  function sign(msgHash, privKey, opts = defaultSigOpts) {\n    const {\n      seed,\n      k2sig\n    } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n    const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(CURVE.hash.outputLen, CURVE.nByteLength, CURVE.hmac);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  }\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\n  Point.BASE._setWindowSize(8);\n  // utils.precompute(8, ProjectivePoint.BASE)\n  /**\n   * Verifies a signature against message hash and public key.\n   * Rejects lowS signatures by default: to override,\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   U1 = hs^-1 mod n\n   *   U2 = rs^-1 mod n\n   *   R = U1⋅G - U2⋅P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n    const sg = signature;\n    msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n    publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    const {\n      lowS,\n      prehash\n    } = opts;\n    let _sig = undefined;\n    let P;\n    try {\n      if (typeof sg === 'string' || sg instanceof Uint8Array) {\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\n        try {\n          _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n          _sig = Signature.fromCompact(sg);\n        }\n      } else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n        const {\n          r,\n          s\n        } = sg;\n        _sig = new Signature(r, s);\n      } else {\n        throw new Error('PARSE');\n      }\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      if (error.message === 'PARSE') throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n      return false;\n    }\n    if (lowS && _sig.hasHighS()) return false;\n    if (prehash) msgHash = CURVE.hash(msgHash);\n    const {\n      r,\n      s\n    } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n    const is = invN(s); // s^-1\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n    if (!R) return false;\n    const v = modN(R.x);\n    return v === r;\n  }\n  return {\n    CURVE,\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    ProjectivePoint: Point,\n    Signature,\n    utils\n  };\n}\n// Implementation of the Shallue and van de Woestijne method for any Weierstrass curve\n// TODO: check if there is a way to merge this with uvRatio in Edwards && move to modular?\n// b = True and y = sqrt(u / v) if (u / v) is square in F, and\n// b = False and y = sqrt(Z * (u / v)) otherwise.\nfunction SWUFpSqrtRatio(Fp, Z) {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = 0n;\n  for (let o = q - 1n; o % 2n === 0n; o /= 2n) l += 1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  const c2 = (q - 1n) / 2n ** c1; // 2. c2 = (q - 1) / (2^c1)        # Integer arithmetic\n  const c3 = (c2 - 1n) / 2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = 2n ** c1 - 1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = 2n ** (c1 - 1n); // 5. c5 = 2^(c1 - 1)              # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + 1n) / 2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u, v) => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > 1; i--) {\n      let tv5 = 2n ** (i - 2n); // 18.    tv5 = i - 2;    19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n\n    return {\n      isValid: isQR,\n      value: tv3\n    };\n  };\n  if (Fp.ORDER % 4n === 3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - 3n) / 4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u, v) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return {\n        isValid: isQR,\n        value: y\n      }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % 8n === 5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n// From draft-irtf-cfrg-hash-to-curve-16\nfunction mapToCurveSimpleSWU(Fp, opts) {\n  _modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField(Fp);\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return u => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const {\n      isValid,\n      value\n    } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    x = Fp.div(x, tv4); // 25.   x = x / tv4\n    return {\n      x,\n      y\n    };\n  };\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/curves/esm/abstract/weierstrass.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"encodeToCurve\": () => (/* binding */ encodeToCurve),\n/* harmony export */   \"hashToCurve\": () => (/* binding */ hashToCurve),\n/* harmony export */   \"schnorr\": () => (/* binding */ schnorr),\n/* harmony export */   \"secp256k1\": () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_shortw_utils.js */ \"./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n  const P = secp256k1P;\n  // prettier-ignore\n  const _3n = BigInt(3),\n    _6n = BigInt(6),\n    _11n = BigInt(11),\n    _22n = BigInt(22);\n  // prettier-ignore\n  const _23n = BigInt(23),\n    _44n = BigInt(44),\n    _88n = BigInt(88);\n  const b2 = y * y * y % P; // x^3, 11\n  const b3 = b2 * b2 * y % P; // x^7\n  const b6 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b3, _3n, P) * b3 % P;\n  const b9 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b6, _3n, P) * b3 % P;\n  const b11 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b9, _2n, P) * b2 % P;\n  const b22 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b11, _11n, P) * b11 % P;\n  const b44 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b22, _22n, P) * b22 % P;\n  const b88 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b44, _44n, P) * b44 % P;\n  const b176 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b88, _88n, P) * b88 % P;\n  const b220 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b176, _44n, P) * b44 % P;\n  const b223 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b220, _3n, P) * b3 % P;\n  const t1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b223, _23n, P) * b22 % P;\n  const t2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(t1, _6n, P) * b2 % P;\n  const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(t2, _2n, P);\n  if (!Fp.eql(Fp.sqr(root), y)) throw new Error('Cannot find square root');\n  return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.Fp)(secp256k1P, undefined, undefined, {\n  sqrt: sqrtMod\n});\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_6__.createCurve)({\n  a: BigInt(0),\n  b: BigInt(7),\n  Fp,\n  n: secp256k1N,\n  // Base point (x, y) aka generator point\n  Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n  Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n  h: BigInt(1),\n  lowS: true,\n  /**\n   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n   */\n  endo: {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    splitScalar: k => {\n      const n = secp256k1N;\n      const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n      const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n      const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n      const b2 = a1;\n      const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n      const c1 = divNearest(b2 * k, n);\n      const c2 = divNearest(-b1 * k, n);\n      let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(k - c1 * a1 - c2 * a2, n);\n      let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(-c1 * b1 - c2 * b2, n);\n      const k1neg = k1 > POW_2_128;\n      const k2neg = k2 > POW_2_128;\n      if (k1neg) k1 = n - k1;\n      if (k2neg) k2 = n - k2;\n      if (k1 > POW_2_128 || k2 > POW_2_128) {\n        throw new Error('splitScalar: Endomorphism failed, k=' + k);\n      }\n      return {\n        k1neg,\n        k1,\n        k2neg,\n        k2\n      };\n    }\n  }\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = x => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = x => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n  let tagP = TAGGED_HASH_PREFIXES[tag];\n  if (tagP === undefined) {\n    const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256)(Uint8Array.from(tag, c => c.charCodeAt(0)));\n    tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(tagH, tagH);\n    TAGGED_HASH_PREFIXES[tag] = tagP;\n  }\n  return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = point => point.toRawBytes(true).slice(1);\nconst numTo32b = n => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.numberToBytesBE)(n, 32);\nconst modP = x => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(x, secp256k1P);\nconst modN = x => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n  let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n  const scalar = p.hasEvenY() ? d_ : modN(-d_);\n  return {\n    scalar: scalar,\n    bytes: pointToBytes(p)\n  };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n  if (!fe(x)) throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n  const xx = modP(x * x);\n  const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n  let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n  if (y % 2n !== 0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n  const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n  p.assertValidity();\n  return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n  return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n  return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(32)) {\n  const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)('message', message);\n  const {\n    bytes: px,\n    scalar: d\n  } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n  const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n  const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n  const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n  if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n  const {\n    bytes: rx,\n    scalar: k\n  } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n  sig.set(rx, 0);\n  sig.set(numTo32b(modN(k + e * d)), 32);\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n  const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)('signature', signature, 64);\n  const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)('message', message);\n  const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)('publicKey', publicKey, 32);\n  try {\n    const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n    const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n    if (!fe(r)) return false;\n    const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n    if (!ge(s)) return false;\n    const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n    const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n    if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n    return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n  } catch (error) {\n    return false;\n  }\n}\nconst schnorr = {\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  utils: {\n    randomPrivateKey: secp256k1.utils.randomPrivateKey,\n    lift_x,\n    pointToBytes,\n    numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.numberToBytesBE,\n    bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE,\n    taggedHash,\n    mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod\n  }\n};\nconst isoMap = _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap(Fp, [\n// xNum\n['0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7', '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581', '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262', '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c'],\n// xDen\n['0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b', '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14', '0x0000000000000000000000000000000000000000000000000000000000000001' // LAST 1\n],\n// yNum\n['0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c', '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3', '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931', '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84'],\n// yDen\n['0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b', '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573', '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f', '0x0000000000000000000000000000000000000000000000000000000000000001' // LAST 1\n]].map(i => i.map(j => BigInt(j))));\nconst mapSWU = (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp, {\n  A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n  B: BigInt('1771'),\n  Z: Fp.create(BigInt('-11'))\n});\nconst {\n  hashToCurve,\n  encodeToCurve\n} = _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher(secp256k1.ProjectivePoint, scalars => {\n  const {\n    x,\n    y\n  } = mapSWU(Fp.create(scalars[0]));\n  return isoMap(x, y);\n}, {\n  DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n  encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n  p: Fp.ORDER,\n  m: 1,\n  k: 128,\n  expand: 'xmd',\n  hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256\n});\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/curves/esm/secp256k1.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bool\": () => (/* binding */ bool),\n/* harmony export */   \"bytes\": () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"exists\": () => (/* binding */ exists),\n/* harmony export */   \"hash\": () => (/* binding */ hash),\n/* harmony export */   \"number\": () => (/* binding */ number),\n/* harmony export */   \"output\": () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n  if (!(b instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length)) throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\nconst assert = {\n  number,\n  bool,\n  bytes,\n  hash,\n  exists,\n  output\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SHA2\": () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number(value >> _32n & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n  constructor(blockLen, outputLen, padOffset, isLE) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.finished = false;\n    this.length = 0;\n    this.pos = 0;\n    this.destroyed = false;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(this.buffer);\n  }\n  update(data) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n    const {\n      view,\n      buffer,\n      blockLen\n    } = this;\n    data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n    const len = data.length;\n    for (let pos = 0; pos < len;) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const {\n      buffer,\n      view,\n      blockLen,\n      isLE\n    } = this;\n    let {\n      pos\n    } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const {\n      buffer,\n      outputLen\n    } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to) {\n    to || (to = new this.constructor());\n    to.set(...this.get());\n    const {\n      blockLen,\n      buffer,\n      length,\n      finished,\n      destroyed,\n      pos\n    } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"crypto\": () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hmac\": () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n  constructor(hash, _key) {\n    super();\n    this.finished = false;\n    this.destroyed = false;\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n    const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_key);\n    this.iHash = hash.create();\n    if (typeof this.iHash.update !== 'function') throw new TypeError('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create();\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to) {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to || (to = Object.create(Object.getPrototypeOf(this), {}));\n    const {\n      oHash,\n      iHash,\n      finished,\n      destroyed,\n      blockLen,\n      outputLen\n    } = this;\n    to = to;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"sha224\": () => (/* binding */ sha224),\n/* harmony export */   \"sha256\": () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Choice: a ? b : c\nconst Chi = (a, b, c) => a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => a & b ^ a & c ^ b & c;\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n  constructor() {\n    super(64, 32, 8, false);\n    // We cannot use array here since array allows indexing by variable\n    // which means optimizer/compiler cannot use registers.\n    this.A = IV[0] | 0;\n    this.B = IV[1] | 0;\n    this.C = IV[2] | 0;\n    this.D = IV[3] | 0;\n    this.E = IV[4] | 0;\n    this.F = IV[5] | 0;\n    this.G = IV[6] | 0;\n    this.H = IV[7] | 0;\n  }\n  get() {\n    const {\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H\n    } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  set(A, B, C, D, E, F, G, H) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  process(view, offset) {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ W15 >>> 3;\n      const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ W2 >>> 10;\n      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let {\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H\n    } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n      const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n      const T2 = sigma0 + Maj(A, B, C) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = D + T1 | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = T1 + T2 | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = A + this.A | 0;\n    B = B + this.B | 0;\n    C = C + this.C | 0;\n    D = D + this.D | 0;\n    E = E + this.E | 0;\n    F = F + this.F | 0;\n    G = G + this.G | 0;\n    H = H + this.H | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  constructor() {\n    super();\n    this.A = 0xc1059ed8 | 0;\n    this.B = 0x367cd507 | 0;\n    this.C = 0x3070dd17 | 0;\n    this.D = 0xf70e5939 | 0;\n    this.E = 0xffc00b31 | 0;\n    this.F = 0x68581511 | 0;\n    this.G = 0x64f98fa7 | 0;\n    this.H = 0xbefa4fa4 | 0;\n    this.outputLen = 28;\n  }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Hash\": () => (/* binding */ Hash),\n/* harmony export */   \"asyncLoop\": () => (/* binding */ asyncLoop),\n/* harmony export */   \"bytesToHex\": () => (/* binding */ bytesToHex),\n/* harmony export */   \"checkOpts\": () => (/* binding */ checkOpts),\n/* harmony export */   \"concatBytes\": () => (/* binding */ concatBytes),\n/* harmony export */   \"createView\": () => (/* binding */ createView),\n/* harmony export */   \"hexToBytes\": () => (/* binding */ hexToBytes),\n/* harmony export */   \"isLE\": () => (/* binding */ isLE),\n/* harmony export */   \"nextTick\": () => (/* binding */ nextTick),\n/* harmony export */   \"randomBytes\": () => (/* binding */ randomBytes),\n/* harmony export */   \"rotr\": () => (/* binding */ rotr),\n/* harmony export */   \"toBytes\": () => (/* binding */ toBytes),\n/* harmony export */   \"u32\": () => (/* binding */ u32),\n/* harmony export */   \"u8\": () => (/* binding */ u8),\n/* harmony export */   \"utf8ToBytes\": () => (/* binding */ utf8ToBytes),\n/* harmony export */   \"wrapConstructor\": () => (/* binding */ wrapConstructor),\n/* harmony export */   \"wrapConstructorWithOpts\": () => (/* binding */ wrapConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use `globalThis.crypto`, but node.js versions earlier than v19 don't\n// declare it in global scope. For node.js, package.json#exports field mapping\n// rewrites import from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\n// Cast array to different type\nconst u8 = arr => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => word << 32 - shift | word >>> shift;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef])) // 'deadbeef'\n */\nfunction bytesToHex(uint8a) {\n  // pre-caching improves the speed 6x\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  let hex = '';\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n  return hex;\n}\n/**\n * @example hexToBytes('deadbeef') // Uint8Array.from([0xde, 0xad, 0xbe, 0xef])\n */\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  const array = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => {};\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\nfunction utf8ToBytes(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n  }\n  return new TextEncoder().encode(str);\n}\nfunction toBytes(data) {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!(data instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n  return data;\n}\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nfunction concatBytes(...arrays) {\n  if (!arrays.every(a => a instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\n// For runtime check if class implements interface\nclass Hash {\n  // Safe version that clones internal state\n  clone() {\n    return this._cloneInto();\n  }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = obj => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n  if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts))) throw new TypeError('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged;\n}\nfunction wrapConstructor(hashConstructor) {\n  const hashC = message => hashConstructor().update(toBytes(message)).digest();\n  const tmp = hashConstructor();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashConstructor();\n  return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({});\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = opts => hashCons(opts);\n  return hashC;\n}\n/**\n * Secure PRNG. Uses `globalThis.crypto` or node.js crypto module.\n */\nfunction randomBytes(bytesLength = 32) {\n  if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n    return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_sha2.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_sha2.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SHA2\": () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number(value >> _32n & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n  constructor(blockLen, outputLen, padOffset, isLE) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.finished = false;\n    this.length = 0;\n    this.pos = 0;\n    this.destroyed = false;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n  }\n  update(data) {\n    if (this.destroyed) throw new Error('instance is destroyed');\n    const {\n      view,\n      buffer,\n      blockLen,\n      finished\n    } = this;\n    if (finished) throw new Error('digest() was already called');\n    data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n    const len = data.length;\n    for (let pos = 0; pos < len;) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out) {\n    if (this.destroyed) throw new Error('instance is destroyed');\n    if (!(out instanceof Uint8Array) || out.length < this.outputLen) throw new Error('_Sha2: Invalid output buffer');\n    if (this.finished) throw new Error('digest() was already called');\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const {\n      buffer,\n      view,\n      blockLen,\n      isLE\n    } = this;\n    let {\n      pos\n    } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // NOTE: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64bit of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n    this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));\n  }\n  digest() {\n    const {\n      buffer,\n      outputLen\n    } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to) {\n    to || (to = new this.constructor());\n    to.set(...this.get());\n    const {\n      blockLen,\n      buffer,\n      length,\n      finished,\n      destroyed,\n      pos\n    } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/hashes/esm/_sha2.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/cryptoBrowser.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/cryptoBrowser.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"crypto\": () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = {\n  node: undefined,\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n};\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/hashes/esm/cryptoBrowser.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hmac\": () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n  constructor(hash, _key) {\n    super();\n    this.finished = false;\n    this.destroyed = false;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assertHash)(hash);\n    const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n    this.iHash = hash.create();\n    if (!(this.iHash instanceof _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash)) throw new TypeError('Expected instance of class which extends utils.Hash');\n    const blockLen = this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > this.iHash.blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create();\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf) {\n    if (this.destroyed) throw new Error('instance is destroyed');\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out) {\n    if (this.destroyed) throw new Error('instance is destroyed');\n    if (!(out instanceof Uint8Array) || out.length !== this.outputLen) throw new Error('HMAC: Invalid output buffer');\n    if (this.finished) throw new Error('digest() was already called');\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to) {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to || (to = Object.create(Object.getPrototypeOf(this), {}));\n    const {\n      oHash,\n      iHash,\n      finished,\n      destroyed,\n      blockLen,\n      outputLen\n    } = this;\n    to = to;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/hashes/esm/hmac.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"sha256\": () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"./node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Choice: a ? b : c\nconst Chi = (a, b, c) => a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => a & b ^ a & c ^ b & c;\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n  constructor() {\n    super(64, 32, 8, false);\n    // We cannot use array here since array allows indexing by variable\n    // which means optimizer/compiler cannot use registers.\n    this.A = IV[0] | 0;\n    this.B = IV[1] | 0;\n    this.C = IV[2] | 0;\n    this.D = IV[3] | 0;\n    this.E = IV[4] | 0;\n    this.F = IV[5] | 0;\n    this.G = IV[6] | 0;\n    this.H = IV[7] | 0;\n  }\n  get() {\n    const {\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H\n    } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  set(A, B, C, D, E, F, G, H) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  process(view, offset) {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ W15 >>> 3;\n      const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ W2 >>> 10;\n      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let {\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H\n    } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n      const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n      const T2 = sigma0 + Maj(A, B, C) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = D + T1 | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = T1 + T2 | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = A + this.A | 0;\n    B = B + this.B | 0;\n    C = C + this.C | 0;\n    D = D + this.D | 0;\n    E = E + this.E | 0;\n    F = F + this.F | 0;\n    G = G + this.G | 0;\n    H = H + this.H | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/hashes/esm/sha256.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Hash\": () => (/* binding */ Hash),\n/* harmony export */   \"assertBool\": () => (/* binding */ assertBool),\n/* harmony export */   \"assertBytes\": () => (/* binding */ assertBytes),\n/* harmony export */   \"assertHash\": () => (/* binding */ assertHash),\n/* harmony export */   \"assertNumber\": () => (/* binding */ assertNumber),\n/* harmony export */   \"asyncLoop\": () => (/* binding */ asyncLoop),\n/* harmony export */   \"bytesToHex\": () => (/* binding */ bytesToHex),\n/* harmony export */   \"checkOpts\": () => (/* binding */ checkOpts),\n/* harmony export */   \"concatBytes\": () => (/* binding */ concatBytes),\n/* harmony export */   \"createView\": () => (/* binding */ createView),\n/* harmony export */   \"hexToBytes\": () => (/* binding */ hexToBytes),\n/* harmony export */   \"isLE\": () => (/* binding */ isLE),\n/* harmony export */   \"nextTick\": () => (/* binding */ nextTick),\n/* harmony export */   \"randomBytes\": () => (/* binding */ randomBytes),\n/* harmony export */   \"rotr\": () => (/* binding */ rotr),\n/* harmony export */   \"toBytes\": () => (/* binding */ toBytes),\n/* harmony export */   \"u32\": () => (/* binding */ u32),\n/* harmony export */   \"u8\": () => (/* binding */ u8),\n/* harmony export */   \"utf8ToBytes\": () => (/* binding */ utf8ToBytes),\n/* harmony export */   \"wrapConstructor\": () => (/* binding */ wrapConstructor),\n/* harmony export */   \"wrapConstructorWithOpts\": () => (/* binding */ wrapConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"./node_modules/@noble/hashes/esm/cryptoBrowser.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\n\n// Cast array to different type\nconst u8 = arr => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => word << 32 - shift | word >>> shift;\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianess.\n// So, just to be sure not to corrupt anything.\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\nfunction bytesToHex(uint8a) {\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n  return hex;\n}\n/**\n * @example hexToBytes('deadbeef')\n */\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  const array = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte)) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n// Currently avoid insertion of polyfills with packers (browserify/webpack/etc)\n// But setTimeout is pretty slow, maybe worth to investigate howto do minimal polyfill here\nconst nextTick = (() => {\n  const nodeRequire = typeof module !== 'undefined' && typeof module.require === 'function' && module.require.bind(module);\n  try {\n    if (nodeRequire) {\n      const {\n        setImmediate\n      } = nodeRequire('timers');\n      return () => new Promise(resolve => setImmediate(resolve));\n    }\n  } catch (e) {}\n  return () => new Promise(resolve => setTimeout(resolve, 0));\n})();\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\nfunction utf8ToBytes(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n  }\n  return new TextEncoder().encode(str);\n}\nfunction toBytes(data) {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!(data instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n  return data;\n}\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nfunction concatBytes(...arrays) {\n  if (!arrays.every(a => a instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\nfunction assertNumber(n) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction assertBool(b) {\n  if (typeof b !== 'boolean') {\n    throw new Error(`Expected boolean, not ${b}`);\n  }\n}\nfunction assertBytes(bytes, ...lengths) {\n  if (bytes instanceof Uint8Array && (!lengths.length || lengths.includes(bytes.length))) {\n    return;\n  }\n  throw new TypeError(`Expected ${lengths} bytes, not ${typeof bytes} with length=${bytes.length}`);\n}\nfunction assertHash(hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  assertNumber(hash.outputLen);\n  assertNumber(hash.blockLen);\n}\n// For runtime check if class implements interface\nclass Hash {\n  // Safe version that clones internal state\n  clone() {\n    return this._cloneInto();\n  }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = obj => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(def, _opts) {\n  if (_opts !== undefined && (typeof _opts !== 'object' || !isPlainObject(_opts))) throw new TypeError('Options should be object or undefined');\n  const opts = Object.assign(def, _opts);\n  return opts;\n}\nfunction wrapConstructor(hashConstructor) {\n  const hashC = message => hashConstructor().update(toBytes(message)).digest();\n  const tmp = hashConstructor();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashConstructor();\n  return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({});\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = opts => hashCons(opts);\n  return hashC;\n}\n/**\n * Secure PRNG\n */\nfunction randomBytes(bytesLength = 32) {\n  if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.web) {\n    return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.web.getRandomValues(new Uint8Array(bytesLength));\n  } else if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.node) {\n    return new Uint8Array(_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.node.randomBytes(bytesLength).buffer);\n  } else {\n    throw new Error(\"The environment doesn't have randomBytes function\");\n  }\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/hashes/esm/utils.js?");

/***/ }),

/***/ "./node_modules/@noble/secp256k1/lib/esm/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@noble/secp256k1/lib/esm/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("var crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CURVE\": () => (/* binding */ CURVE),\n/* harmony export */   \"Point\": () => (/* binding */ Point),\n/* harmony export */   \"Signature\": () => (/* binding */ Signature),\n/* harmony export */   \"getPublicKey\": () => (/* binding */ getPublicKey),\n/* harmony export */   \"getSharedSecret\": () => (/* binding */ getSharedSecret),\n/* harmony export */   \"recoverPublicKey\": () => (/* binding */ recoverPublicKey),\n/* harmony export */   \"schnorr\": () => (/* binding */ schnorr),\n/* harmony export */   \"sign\": () => (/* binding */ sign),\n/* harmony export */   \"signSync\": () => (/* binding */ signSync),\n/* harmony export */   \"utils\": () => (/* binding */ utils),\n/* harmony export */   \"verify\": () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"?ce41\");\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n  a: _0n,\n  b: BigInt(7),\n  P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n  n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n  h: _1n,\n  Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n  Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee')\n});\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst endo = {\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n  splitScalar(k) {\n    const {\n      n\n    } = CURVE;\n    const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n    const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n    const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n    const b2 = a1;\n    const POW_2_128 = BigInt('0x100000000000000000000000000000000');\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    let k1 = mod(k - c1 * a1 - c2 * a2, n);\n    let k2 = mod(-c1 * b1 - c2 * b2, n);\n    const k1neg = k1 > POW_2_128;\n    const k2neg = k2 > POW_2_128;\n    if (k1neg) k1 = n - k1;\n    if (k2neg) k2 = n - k2;\n    if (k1 > POW_2_128 || k2 > POW_2_128) {\n      throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n    }\n    return {\n      k1neg,\n      k1,\n      k2neg,\n      k2\n    };\n  }\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\n\nfunction weierstrass(x) {\n  const {\n    a,\n    b\n  } = CURVE;\n  const x2 = mod(x * x);\n  const x3 = mod(x2 * x);\n  return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n  constructor(message) {\n    super(message);\n  }\n}\nfunction assertJacPoint(other) {\n  if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');\n}\nclass JacobianPoint {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  static fromAffine(p) {\n    if (!(p instanceof Point)) {\n      throw new TypeError('JacobianPoint#fromAffine: expected Point');\n    }\n    if (p.equals(Point.ZERO)) return JacobianPoint.ZERO;\n    return new JacobianPoint(p.x, p.y, _1n);\n  }\n  static toAffineBatch(points) {\n    const toInv = invertBatch(points.map(p => p.z));\n    return points.map((p, i) => p.toAffine(toInv[i]));\n  }\n  static normalizeZ(points) {\n    return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n  }\n  equals(other) {\n    assertJacPoint(other);\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2\n    } = other;\n    const Z1Z1 = mod(Z1 * Z1);\n    const Z2Z2 = mod(Z2 * Z2);\n    const U1 = mod(X1 * Z2Z2);\n    const U2 = mod(X2 * Z1Z1);\n    const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n    const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n    return U1 === U2 && S1 === S2;\n  }\n  negate() {\n    return new JacobianPoint(this.x, mod(-this.y), this.z);\n  }\n  double() {\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const A = mod(X1 * X1);\n    const B = mod(Y1 * Y1);\n    const C = mod(B * B);\n    const x1b = X1 + B;\n    const D = mod(_2n * (mod(x1b * x1b) - A - C));\n    const E = mod(_3n * A);\n    const F = mod(E * E);\n    const X3 = mod(F - _2n * D);\n    const Y3 = mod(E * (D - X3) - _8n * C);\n    const Z3 = mod(_2n * Y1 * Z1);\n    return new JacobianPoint(X3, Y3, Z3);\n  }\n  add(other) {\n    assertJacPoint(other);\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2\n    } = other;\n    if (X2 === _0n || Y2 === _0n) return this;\n    if (X1 === _0n || Y1 === _0n) return other;\n    const Z1Z1 = mod(Z1 * Z1);\n    const Z2Z2 = mod(Z2 * Z2);\n    const U1 = mod(X1 * Z2Z2);\n    const U2 = mod(X2 * Z1Z1);\n    const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n    const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n    const H = mod(U2 - U1);\n    const r = mod(S2 - S1);\n    if (H === _0n) {\n      if (r === _0n) {\n        return this.double();\n      } else {\n        return JacobianPoint.ZERO;\n      }\n    }\n    const HH = mod(H * H);\n    const HHH = mod(H * HH);\n    const V = mod(U1 * HH);\n    const X3 = mod(r * r - HHH - _2n * V);\n    const Y3 = mod(r * (V - X3) - S1 * HHH);\n    const Z3 = mod(Z1 * Z2 * H);\n    return new JacobianPoint(X3, Y3, Z3);\n  }\n  subtract(other) {\n    return this.add(other.negate());\n  }\n  multiplyUnsafe(scalar) {\n    const P0 = JacobianPoint.ZERO;\n    if (typeof scalar === 'bigint' && scalar === _0n) return P0;\n    let n = normalizeScalar(scalar);\n    if (n === _1n) return this;\n    if (!USE_ENDOMORPHISM) {\n      let p = P0;\n      let d = this;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    }\n    let {\n      k1neg,\n      k1,\n      k2neg,\n      k2\n    } = endo.splitScalar(n);\n    let k1p = P0;\n    let k2p = P0;\n    let d = this;\n    while (k1 > _0n || k2 > _0n) {\n      if (k1 & _1n) k1p = k1p.add(d);\n      if (k2 & _1n) k2p = k2p.add(d);\n      d = d.double();\n      k1 >>= _1n;\n      k2 >>= _1n;\n    }\n    if (k1neg) k1p = k1p.negate();\n    if (k2neg) k2p = k2p.negate();\n    k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n    return k1p.add(k2p);\n  }\n  precomputeWindow(W) {\n    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n    const points = [];\n    let p = this;\n    let base = p;\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n      for (let i = 1; i < 2 ** (W - 1); i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n      p = base.double();\n    }\n    return points;\n  }\n  wNAF(n, affinePoint) {\n    if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;\n    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n    if (256 % W) {\n      throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n    }\n    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n    if (!precomputes) {\n      precomputes = this.precomputeWindow(W);\n      if (affinePoint && W !== 1) {\n        precomputes = JacobianPoint.normalizeZ(precomputes);\n        pointPrecomputes.set(affinePoint, precomputes);\n      }\n    }\n    let p = JacobianPoint.ZERO;\n    let f = JacobianPoint.BASE;\n    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n    const windowSize = 2 ** (W - 1);\n    const mask = BigInt(2 ** W - 1);\n    const maxNumber = 2 ** W;\n    const shiftBy = BigInt(W);\n    for (let window = 0; window < windows; window++) {\n      const offset = window * windowSize;\n      let wbits = Number(n & mask);\n      n >>= shiftBy;\n      if (wbits > windowSize) {\n        wbits -= maxNumber;\n        n += _1n;\n      }\n      const offset1 = offset;\n      const offset2 = offset + Math.abs(wbits) - 1;\n      const cond1 = window % 2 !== 0;\n      const cond2 = wbits < 0;\n      if (wbits === 0) {\n        f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n      } else {\n        p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n      }\n    }\n    return {\n      p,\n      f\n    };\n  }\n  multiply(scalar, affinePoint) {\n    let n = normalizeScalar(scalar);\n    let point;\n    let fake;\n    if (USE_ENDOMORPHISM) {\n      const {\n        k1neg,\n        k1,\n        k2neg,\n        k2\n      } = endo.splitScalar(n);\n      let {\n        p: k1p,\n        f: f1p\n      } = this.wNAF(k1, affinePoint);\n      let {\n        p: k2p,\n        f: f2p\n      } = this.wNAF(k2, affinePoint);\n      k1p = constTimeNegate(k1neg, k1p);\n      k2p = constTimeNegate(k2neg, k2p);\n      k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n      point = k1p.add(k2p);\n      fake = f1p.add(f2p);\n    } else {\n      const {\n        p,\n        f\n      } = this.wNAF(n, affinePoint);\n      point = p;\n      fake = f;\n    }\n    return JacobianPoint.normalizeZ([point, fake])[0];\n  }\n  toAffine(invZ) {\n    const {\n      x,\n      y,\n      z\n    } = this;\n    const is0 = this.equals(JacobianPoint.ZERO);\n    if (invZ == null) invZ = is0 ? _8n : invert(z);\n    const iz1 = invZ;\n    const iz2 = mod(iz1 * iz1);\n    const iz3 = mod(iz2 * iz1);\n    const ax = mod(x * iz2);\n    const ay = mod(y * iz3);\n    const zz = mod(z * iz1);\n    if (is0) return Point.ZERO;\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return new Point(ax, ay);\n  }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\nconst pointPrecomputes = new WeakMap();\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  _setWindowSize(windowSize) {\n    this._WINDOW_SIZE = windowSize;\n    pointPrecomputes.delete(this);\n  }\n  hasEvenY() {\n    return this.y % _2n === _0n;\n  }\n  static fromCompressedHex(bytes) {\n    const isShort = bytes.length === 32;\n    const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n    if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n    const y2 = weierstrass(x);\n    let y = sqrtMod(y2);\n    const isYOdd = (y & _1n) === _1n;\n    if (isShort) {\n      if (isYOdd) y = mod(-y);\n    } else {\n      const isFirstByteOdd = (bytes[0] & 1) === 1;\n      if (isFirstByteOdd !== isYOdd) y = mod(-y);\n    }\n    const point = new Point(x, y);\n    point.assertValidity();\n    return point;\n  }\n  static fromUncompressedHex(bytes) {\n    const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n    const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n    const point = new Point(x, y);\n    point.assertValidity();\n    return point;\n  }\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex);\n    const len = bytes.length;\n    const header = bytes[0];\n    if (len === fieldLen) return this.fromCompressedHex(bytes);\n    if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n      return this.fromCompressedHex(bytes);\n    }\n    if (len === uncompressedLen && header === 0x04) return this.fromUncompressedHex(bytes);\n    throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);\n  }\n  static fromPrivateKey(privateKey) {\n    return Point.BASE.multiply(normalizePrivateKey(privateKey));\n  }\n  static fromSignature(msgHash, signature, recovery) {\n    const {\n      r,\n      s\n    } = normalizeSignature(signature);\n    if (![0, 1, 2, 3].includes(recovery)) throw new Error('Cannot recover: invalid recovery bit');\n    const h = truncateHash(ensureBytes(msgHash));\n    const {\n      n\n    } = CURVE;\n    const radj = recovery === 2 || recovery === 3 ? r + n : r;\n    const rinv = invert(radj, n);\n    const u1 = mod(-h * rinv, n);\n    const u2 = mod(s * rinv, n);\n    const prefix = recovery & 1 ? '03' : '02';\n    const R = Point.fromHex(prefix + numTo32bStr(radj));\n    const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n    if (!Q) throw new Error('Cannot recover signature: point at infinify');\n    Q.assertValidity();\n    return Q;\n  }\n  toRawBytes(isCompressed = false) {\n    return hexToBytes(this.toHex(isCompressed));\n  }\n  toHex(isCompressed = false) {\n    const x = numTo32bStr(this.x);\n    if (isCompressed) {\n      const prefix = this.hasEvenY() ? '02' : '03';\n      return `${prefix}${x}`;\n    } else {\n      return `04${x}${numTo32bStr(this.y)}`;\n    }\n  }\n  toHexX() {\n    return this.toHex(true).slice(2);\n  }\n  toRawX() {\n    return this.toRawBytes(true).slice(1);\n  }\n  assertValidity() {\n    const msg = 'Point is not on elliptic curve';\n    const {\n      x,\n      y\n    } = this;\n    if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);\n    const left = mod(y * y);\n    const right = weierstrass(x);\n    if (mod(left - right) !== _0n) throw new Error(msg);\n  }\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n  negate() {\n    return new Point(this.x, mod(-this.y));\n  }\n  double() {\n    return JacobianPoint.fromAffine(this).double().toAffine();\n  }\n  add(other) {\n    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n  }\n  subtract(other) {\n    return this.add(other.negate());\n  }\n  multiply(scalar) {\n    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n  }\n  multiplyAndAddUnsafe(Q, a, b) {\n    const P = JacobianPoint.fromAffine(this);\n    const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n    const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n    const sum = aP.add(bQ);\n    return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n  }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n  return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n  if (data.length < 2 || data[0] !== 0x02) {\n    throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n  }\n  const len = data[1];\n  const res = data.subarray(2, len + 2);\n  if (!len || res.length !== len) {\n    throw new Error(`Invalid signature integer: wrong length`);\n  }\n  if (res[0] === 0x00 && res[1] <= 0x7f) {\n    throw new Error('Invalid signature integer: trailing length');\n  }\n  return {\n    data: bytesToNumber(res),\n    left: data.subarray(len + 2)\n  };\n}\nfunction parseDERSignature(data) {\n  if (data.length < 2 || data[0] != 0x30) {\n    throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n  }\n  if (data[1] !== data.length - 2) {\n    throw new Error('Invalid signature: incorrect length');\n  }\n  const {\n    data: r,\n    left: sBytes\n  } = parseDERInt(data.subarray(2));\n  const {\n    data: s,\n    left: rBytesLeft\n  } = parseDERInt(sBytes);\n  if (rBytesLeft.length) {\n    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n  }\n  return {\n    r,\n    s\n  };\n}\nclass Signature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n  static fromCompact(hex) {\n    const arr = hex instanceof Uint8Array;\n    const name = 'Signature.fromCompact';\n    if (typeof hex !== 'string' && !arr) throw new TypeError(`${name}: Expected string or Uint8Array`);\n    const str = arr ? bytesToHex(hex) : hex;\n    if (str.length !== 128) throw new Error(`${name}: Expected 64-byte hex`);\n    return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n  }\n  static fromDER(hex) {\n    const arr = hex instanceof Uint8Array;\n    if (typeof hex !== 'string' && !arr) throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n    const {\n      r,\n      s\n    } = parseDERSignature(arr ? hex : hexToBytes(hex));\n    return new Signature(r, s);\n  }\n  static fromHex(hex) {\n    return this.fromDER(hex);\n  }\n  assertValidity() {\n    const {\n      r,\n      s\n    } = this;\n    if (!isWithinCurveOrder(r)) throw new Error('Invalid Signature: r must be 0 < r < n');\n    if (!isWithinCurveOrder(s)) throw new Error('Invalid Signature: s must be 0 < s < n');\n  }\n  hasHighS() {\n    const HALF = CURVE.n >> _1n;\n    return this.s > HALF;\n  }\n  normalizeS() {\n    return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n  }\n  toDERRawBytes() {\n    return hexToBytes(this.toDERHex());\n  }\n  toDERHex() {\n    const sHex = sliceDER(numberToHexUnpadded(this.s));\n    const rHex = sliceDER(numberToHexUnpadded(this.r));\n    const sHexL = sHex.length / 2;\n    const rHexL = rHex.length / 2;\n    const sLen = numberToHexUnpadded(sHexL);\n    const rLen = numberToHexUnpadded(rHexL);\n    const length = numberToHexUnpadded(rHexL + sHexL + 4);\n    return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n  }\n  toRawBytes() {\n    return this.toDERRawBytes();\n  }\n  toHex() {\n    return this.toDERHex();\n  }\n  toCompactRawBytes() {\n    return hexToBytes(this.toCompactHex());\n  }\n  toCompactHex() {\n    return numTo32bStr(this.r) + numTo32bStr(this.s);\n  }\n}\nfunction concatBytes(...arrays) {\n  if (!arrays.every(b => b instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  let hex = '';\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n  return hex;\n}\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n  if (typeof num !== 'bigint') throw new Error('Expected bigint');\n  if (!(_0n <= num && num < POW_2_256)) throw new Error('Expected number 0 <= n < 2^256');\n  return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n  const b = hexToBytes(numTo32bStr(num));\n  if (b.length !== 32) throw new Error('Error: expected 32 bytes');\n  return b;\n}\nfunction numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n  }\n  return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n  const array = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\nfunction bytesToNumber(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n  if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0) return BigInt(num);\n  if (typeof num === 'bigint' && isWithinCurveOrder(num)) return num;\n  throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n  const {\n    P\n  } = CURVE;\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= P;\n  }\n  return res;\n}\nfunction sqrtMod(x) {\n  const {\n    P\n  } = CURVE;\n  const _6n = BigInt(6);\n  const _11n = BigInt(11);\n  const _22n = BigInt(22);\n  const _23n = BigInt(23);\n  const _44n = BigInt(44);\n  const _88n = BigInt(88);\n  const b2 = x * x * x % P;\n  const b3 = b2 * b2 * x % P;\n  const b6 = pow2(b3, _3n) * b3 % P;\n  const b9 = pow2(b6, _3n) * b3 % P;\n  const b11 = pow2(b9, _2n) * b2 % P;\n  const b22 = pow2(b11, _11n) * b11 % P;\n  const b44 = pow2(b22, _22n) * b22 % P;\n  const b88 = pow2(b44, _44n) * b44 % P;\n  const b176 = pow2(b88, _88n) * b88 % P;\n  const b220 = pow2(b176, _44n) * b44 % P;\n  const b223 = pow2(b220, _3n) * b3 % P;\n  const t1 = pow2(b223, _23n) * b22 % P;\n  const t2 = pow2(t1, _6n) * b2 % P;\n  const rt = pow2(t2, _2n);\n  const xc = rt * rt % P;\n  if (xc !== x) throw new Error('Cannot find square root');\n  return rt;\n}\nfunction invert(number, modulo = CURVE.P) {\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n  let a = mod(number, modulo);\n  let b = modulo;\n  let x = _0n,\n    y = _1n,\n    u = _1n,\n    v = _0n;\n  while (a !== _0n) {\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n  const scratch = new Array(nums.length);\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (num === _0n) return acc;\n    scratch[i] = acc;\n    return mod(acc * num, p);\n  }, _1n);\n  const inverted = invert(lastMultiplied, p);\n  nums.reduceRight((acc, num, i) => {\n    if (num === _0n) return acc;\n    scratch[i] = mod(acc * scratch[i], p);\n    return mod(acc * num, p);\n  }, inverted);\n  return scratch;\n}\nfunction bits2int_2(bytes) {\n  const delta = bytes.length * 8 - groupLen * 8;\n  const num = bytesToNumber(bytes);\n  return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash, truncateOnly = false) {\n  const h = bits2int_2(hash);\n  if (truncateOnly) return h;\n  const {\n    n\n  } = CURVE;\n  return h >= n ? h - n : h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n  constructor(hashLen, qByteLen) {\n    this.hashLen = hashLen;\n    this.qByteLen = qByteLen;\n    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n    this.v = new Uint8Array(hashLen).fill(1);\n    this.k = new Uint8Array(hashLen).fill(0);\n    this.counter = 0;\n  }\n  hmac(...values) {\n    return utils.hmacSha256(this.k, ...values);\n  }\n  hmacSync(...values) {\n    return _hmacSha256Sync(this.k, ...values);\n  }\n  checkSync() {\n    if (typeof _hmacSha256Sync !== 'function') throw new ShaError('hmacSha256Sync needs to be set');\n  }\n  incr() {\n    if (this.counter >= 1000) throw new Error('Tried 1,000 k values for sign(), all were invalid');\n    this.counter += 1;\n  }\n  async reseed(seed = new Uint8Array()) {\n    this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n    this.v = await this.hmac(this.v);\n    if (seed.length === 0) return;\n    this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n    this.v = await this.hmac(this.v);\n  }\n  reseedSync(seed = new Uint8Array()) {\n    this.checkSync();\n    this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n    this.v = this.hmacSync(this.v);\n    if (seed.length === 0) return;\n    this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n    this.v = this.hmacSync(this.v);\n  }\n  async generate() {\n    this.incr();\n    let len = 0;\n    const out = [];\n    while (len < this.qByteLen) {\n      this.v = await this.hmac(this.v);\n      const sl = this.v.slice();\n      out.push(sl);\n      len += this.v.length;\n    }\n    return concatBytes(...out);\n  }\n  generateSync() {\n    this.checkSync();\n    this.incr();\n    let len = 0;\n    const out = [];\n    while (len < this.qByteLen) {\n      this.v = this.hmacSync(this.v);\n      const sl = this.v.slice();\n      out.push(sl);\n      len += this.v.length;\n    }\n    return concatBytes(...out);\n  }\n}\nfunction isWithinCurveOrder(num) {\n  return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n  return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d, lowS = true) {\n  const {\n    n\n  } = CURVE;\n  const k = truncateHash(kBytes, true);\n  if (!isWithinCurveOrder(k)) return;\n  const kinv = invert(k, n);\n  const q = Point.BASE.multiply(k);\n  const r = mod(q.x, n);\n  if (r === _0n) return;\n  const s = mod(kinv * mod(m + d * r, n), n);\n  if (s === _0n) return;\n  let sig = new Signature(r, s);\n  let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n  if (lowS && sig.hasHighS()) {\n    sig = sig.normalizeS();\n    recovery ^= 1;\n  }\n  return {\n    sig,\n    recovery\n  };\n}\nfunction normalizePrivateKey(key) {\n  let num;\n  if (typeof key === 'bigint') {\n    num = key;\n  } else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n    num = BigInt(key);\n  } else if (typeof key === 'string') {\n    if (key.length !== 2 * groupLen) throw new Error('Expected 32 bytes of private key');\n    num = hexToNumber(key);\n  } else if (key instanceof Uint8Array) {\n    if (key.length !== groupLen) throw new Error('Expected 32 bytes of private key');\n    num = bytesToNumber(key);\n  } else {\n    throw new TypeError('Expected valid private key');\n  }\n  if (!isWithinCurveOrder(num)) throw new Error('Expected private key: 0 < key < n');\n  return num;\n}\nfunction normalizePublicKey(publicKey) {\n  if (publicKey instanceof Point) {\n    publicKey.assertValidity();\n    return publicKey;\n  } else {\n    return Point.fromHex(publicKey);\n  }\n}\nfunction normalizeSignature(signature) {\n  if (signature instanceof Signature) {\n    signature.assertValidity();\n    return signature;\n  }\n  try {\n    return Signature.fromDER(signature);\n  } catch (error) {\n    return Signature.fromCompact(signature);\n  }\n}\nfunction getPublicKey(privateKey, isCompressed = false) {\n  return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nfunction recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n  return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isProbPub(item) {\n  const arr = item instanceof Uint8Array;\n  const str = typeof item === 'string';\n  const len = (arr || str) && item.length;\n  if (arr) return len === compressedLen || len === uncompressedLen;\n  if (str) return len === compressedLen * 2 || len === uncompressedLen * 2;\n  if (item instanceof Point) return true;\n  return false;\n}\nfunction getSharedSecret(privateA, publicB, isCompressed = false) {\n  if (isProbPub(privateA)) throw new TypeError('getSharedSecret: first arg must be private key');\n  if (!isProbPub(publicB)) throw new TypeError('getSharedSecret: second arg must be public key');\n  const b = normalizePublicKey(publicB);\n  b.assertValidity();\n  return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n  const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n  return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n  const z1 = bits2int(bytes);\n  const z2 = mod(z1, CURVE.n);\n  return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n  return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n  if (msgHash == null) throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n  const h1 = ensureBytes(msgHash);\n  const d = normalizePrivateKey(privateKey);\n  const seedArgs = [int2octets(d), bits2octets(h1)];\n  if (extraEntropy != null) {\n    if (extraEntropy === true) extraEntropy = utils.randomBytes(fieldLen);\n    const e = ensureBytes(extraEntropy);\n    if (e.length !== fieldLen) throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);\n    seedArgs.push(e);\n  }\n  const seed = concatBytes(...seedArgs);\n  const m = bits2int(h1);\n  return {\n    seed,\n    m,\n    d\n  };\n}\nfunction finalizeSig(recSig, opts) {\n  const {\n    sig,\n    recovery\n  } = recSig;\n  const {\n    der,\n    recovered\n  } = Object.assign({\n    canonical: true,\n    der: true\n  }, opts);\n  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n  return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n  const {\n    seed,\n    m,\n    d\n  } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n  const drbg = new HmacDrbg(hashLen, groupLen);\n  await drbg.reseed(seed);\n  let sig;\n  while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical))) await drbg.reseed();\n  return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n  const {\n    seed,\n    m,\n    d\n  } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n  const drbg = new HmacDrbg(hashLen, groupLen);\n  drbg.reseedSync(seed);\n  let sig;\n  while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical))) drbg.reseedSync();\n  return finalizeSig(sig, opts);\n}\n\nconst vopts = {\n  strict: true\n};\nfunction verify(signature, msgHash, publicKey, opts = vopts) {\n  let sig;\n  try {\n    sig = normalizeSignature(signature);\n    msgHash = ensureBytes(msgHash);\n  } catch (error) {\n    return false;\n  }\n  const {\n    r,\n    s\n  } = sig;\n  if (opts.strict && sig.hasHighS()) return false;\n  const h = truncateHash(msgHash);\n  let P;\n  try {\n    P = normalizePublicKey(publicKey);\n  } catch (error) {\n    return false;\n  }\n  const {\n    n\n  } = CURVE;\n  const sinv = invert(s, n);\n  const u1 = mod(h * sinv, n);\n  const u2 = mod(r * sinv, n);\n  const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n  if (!R) return false;\n  const v = mod(R.x, n);\n  return v === r;\n}\nfunction schnorrChallengeFinalize(ch) {\n  return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex);\n    if (bytes.length !== 64) throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n    const r = bytesToNumber(bytes.subarray(0, 32));\n    const s = bytesToNumber(bytes.subarray(32, 64));\n    return new SchnorrSignature(r, s);\n  }\n  assertValidity() {\n    const {\n      r,\n      s\n    } = this;\n    if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error('Invalid signature');\n  }\n  toHex() {\n    return numTo32bStr(this.r) + numTo32bStr(this.s);\n  }\n  toRawBytes() {\n    return hexToBytes(this.toHex());\n  }\n}\nfunction schnorrGetPublicKey(privateKey) {\n  return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n  constructor(message, privateKey, auxRand = utils.randomBytes()) {\n    if (message == null) throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n    this.m = ensureBytes(message);\n    const {\n      x,\n      scalar\n    } = this.getScalar(normalizePrivateKey(privateKey));\n    this.px = x;\n    this.d = scalar;\n    this.rand = ensureBytes(auxRand);\n    if (this.rand.length !== 32) throw new TypeError('sign: Expected 32 bytes of aux randomness');\n  }\n  getScalar(priv) {\n    const point = Point.fromPrivateKey(priv);\n    const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n    return {\n      point,\n      scalar,\n      x: point.toRawX()\n    };\n  }\n  initNonce(d, t0h) {\n    return numTo32b(d ^ bytesToNumber(t0h));\n  }\n  finalizeNonce(k0h) {\n    const k0 = mod(bytesToNumber(k0h), CURVE.n);\n    if (k0 === _0n) throw new Error('sign: Creation of signature failed. k is zero');\n    const {\n      point: R,\n      x: rx,\n      scalar: k\n    } = this.getScalar(k0);\n    return {\n      R,\n      rx,\n      k\n    };\n  }\n  finalizeSig(R, k, e, d) {\n    return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n  }\n  error() {\n    throw new Error('sign: Invalid signature produced');\n  }\n  async calc() {\n    const {\n      m,\n      d,\n      px,\n      rand\n    } = this;\n    const tag = utils.taggedHash;\n    const t = this.initNonce(d, await tag(TAGS.aux, rand));\n    const {\n      R,\n      rx,\n      k\n    } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n    const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n    const sig = this.finalizeSig(R, k, e, d);\n    if (!(await schnorrVerify(sig, m, px))) this.error();\n    return sig;\n  }\n  calcSync() {\n    const {\n      m,\n      d,\n      px,\n      rand\n    } = this;\n    const tag = utils.taggedHashSync;\n    const t = this.initNonce(d, tag(TAGS.aux, rand));\n    const {\n      R,\n      rx,\n      k\n    } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n    const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n    const sig = this.finalizeSig(R, k, e, d);\n    if (!schnorrVerifySync(sig, m, px)) this.error();\n    return sig;\n  }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n  return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n  return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n  const raw = signature instanceof SchnorrSignature;\n  const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n  if (raw) sig.assertValidity();\n  return {\n    ...sig,\n    m: ensureBytes(message),\n    P: normalizePublicKey(publicKey)\n  };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n  const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n  if (!R || !R.hasEvenY() || R.x !== r) return false;\n  return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n  try {\n    const {\n      r,\n      s,\n      m,\n      P\n    } = initSchnorrVerify(signature, message, publicKey);\n    const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n    return finalizeSchnorrVerify(r, P, s, e);\n  } catch (error) {\n    return false;\n  }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n  try {\n    const {\n      r,\n      s,\n      m,\n      P\n    } = initSchnorrVerify(signature, message, publicKey);\n    const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n    return finalizeSchnorrVerify(r, P, s, e);\n  } catch (error) {\n    if (error instanceof ShaError) throw error;\n    return false;\n  }\n}\nconst schnorr = {\n  Signature: SchnorrSignature,\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  signSync: schnorrSignSync,\n  verifySync: schnorrVerifySync\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n  node: /*#__PURE__*/ (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(crypto__WEBPACK_IMPORTED_MODULE_0__, 2))),\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n};\nconst TAGS = {\n  challenge: 'BIP0340/challenge',\n  aux: 'BIP0340/aux',\n  nonce: 'BIP0340/nonce'\n};\nconst TAGGED_HASH_PREFIXES = {};\nconst utils = {\n  bytesToHex,\n  hexToBytes,\n  concatBytes,\n  mod,\n  invert,\n  isValidPrivateKey(privateKey) {\n    try {\n      normalizePrivateKey(privateKey);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  },\n  _bigintTo32Bytes: numTo32b,\n  _normalizePrivateKey: normalizePrivateKey,\n  hashToPrivateKey: hash => {\n    hash = ensureBytes(hash);\n    const minLen = groupLen + 8;\n    if (hash.length < minLen || hash.length > 1024) {\n      throw new Error(`Expected valid bytes of private key as per FIPS 186`);\n    }\n    const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n    return numTo32b(num);\n  },\n  randomBytes: (bytesLength = 32) => {\n    if (crypto.web) {\n      return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (crypto.node) {\n      const {\n        randomBytes\n      } = crypto.node;\n      return Uint8Array.from(randomBytes(bytesLength));\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),\n  precompute(windowSize = 8, point = Point.BASE) {\n    const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n    cached._setWindowSize(windowSize);\n    cached.multiply(_3n);\n    return cached;\n  },\n  sha256: async (...messages) => {\n    if (crypto.web) {\n      const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n      return new Uint8Array(buffer);\n    } else if (crypto.node) {\n      const {\n        createHash\n      } = crypto.node;\n      const hash = createHash('sha256');\n      messages.forEach(m => hash.update(m));\n      return Uint8Array.from(hash.digest());\n    } else {\n      throw new Error(\"The environment doesn't have sha256 function\");\n    }\n  },\n  hmacSha256: async (key, ...messages) => {\n    if (crypto.web) {\n      const ckey = await crypto.web.subtle.importKey('raw', key, {\n        name: 'HMAC',\n        hash: {\n          name: 'SHA-256'\n        }\n      }, false, ['sign']);\n      const message = concatBytes(...messages);\n      const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n      return new Uint8Array(buffer);\n    } else if (crypto.node) {\n      const {\n        createHmac\n      } = crypto.node;\n      const hash = createHmac('sha256', key);\n      messages.forEach(m => hash.update(m));\n      return Uint8Array.from(hash.digest());\n    } else {\n      throw new Error(\"The environment doesn't have hmac-sha256 function\");\n    }\n  },\n  sha256Sync: undefined,\n  hmacSha256Sync: undefined,\n  taggedHash: async (tag, ...messages) => {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n      const tagH = await utils.sha256(Uint8Array.from(tag, c => c.charCodeAt(0)));\n      tagP = concatBytes(tagH, tagH);\n      TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return utils.sha256(tagP, ...messages);\n  },\n  taggedHashSync: (tag, ...messages) => {\n    if (typeof _sha256Sync !== 'function') throw new ShaError('sha256Sync is undefined, you need to set it');\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n      const tagH = _sha256Sync(Uint8Array.from(tag, c => c.charCodeAt(0)));\n      tagP = concatBytes(tagH, tagH);\n      TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return _sha256Sync(tagP, ...messages);\n  },\n  _JacobianPoint: JacobianPoint\n};\nObject.defineProperties(utils, {\n  sha256Sync: {\n    configurable: false,\n    get() {\n      return _sha256Sync;\n    },\n    set(val) {\n      if (!_sha256Sync) _sha256Sync = val;\n    }\n  },\n  hmacSha256Sync: {\n    configurable: false,\n    get() {\n      return _hmacSha256Sync;\n    },\n    set(val) {\n      if (!_hmacSha256Sync) _hmacSha256Sync = val;\n    }\n  }\n});\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@noble/secp256k1/lib/esm/index.js?");

/***/ }),

/***/ "./node_modules/@scure/base/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@scure/base/lib/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assertNumber\": () => (/* binding */ assertNumber),\n/* harmony export */   \"base16\": () => (/* binding */ base16),\n/* harmony export */   \"base32\": () => (/* binding */ base32),\n/* harmony export */   \"base32crockford\": () => (/* binding */ base32crockford),\n/* harmony export */   \"base32hex\": () => (/* binding */ base32hex),\n/* harmony export */   \"base58\": () => (/* binding */ base58),\n/* harmony export */   \"base58check\": () => (/* binding */ base58check),\n/* harmony export */   \"base58flickr\": () => (/* binding */ base58flickr),\n/* harmony export */   \"base58xmr\": () => (/* binding */ base58xmr),\n/* harmony export */   \"base58xrp\": () => (/* binding */ base58xrp),\n/* harmony export */   \"base64\": () => (/* binding */ base64),\n/* harmony export */   \"base64url\": () => (/* binding */ base64url),\n/* harmony export */   \"bech32\": () => (/* binding */ bech32),\n/* harmony export */   \"bech32m\": () => (/* binding */ bech32m),\n/* harmony export */   \"bytes\": () => (/* binding */ bytes),\n/* harmony export */   \"bytesToString\": () => (/* binding */ bytesToString),\n/* harmony export */   \"hex\": () => (/* binding */ hex),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"stringToBytes\": () => (/* binding */ stringToBytes),\n/* harmony export */   \"utf8\": () => (/* binding */ utf8),\n/* harmony export */   \"utils\": () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction assertNumber(n) {\n  if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\nfunction chain(...args) {\n  const wrap = (a, b) => c => a(b(c));\n  const encode = Array.from(args).reverse().reduce((acc, i) => acc ? wrap(acc, i.encode) : i.encode, undefined);\n  const decode = args.reduce((acc, i) => acc ? wrap(acc, i.decode) : i.decode, undefined);\n  return {\n    encode,\n    decode\n  };\n}\nfunction alphabet(alphabet) {\n  return {\n    encode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('alphabet.encode input should be an array of numbers');\n      return digits.map(i => {\n        assertNumber(i);\n        if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n        return alphabet[i];\n      });\n    },\n    decode: input => {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('alphabet.decode input should be array of strings');\n      return input.map(letter => {\n        if (typeof letter !== 'string') throw new Error(`alphabet.decode: not string element=${letter}`);\n        const index = alphabet.indexOf(letter);\n        if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n        return index;\n      });\n    }\n  };\n}\nfunction join(separator = '') {\n  if (typeof separator !== 'string') throw new Error('join separator should be string');\n  return {\n    encode: from => {\n      if (!Array.isArray(from) || from.length && typeof from[0] !== 'string') throw new Error('join.encode input should be array of strings');\n      for (let i of from) if (typeof i !== 'string') throw new Error(`join.encode: non-string input=${i}`);\n      return from.join(separator);\n    },\n    decode: to => {\n      if (typeof to !== 'string') throw new Error('join.decode input should be string');\n      return to.split(separator);\n    }\n  };\n}\nfunction padding(bits, chr = '=') {\n  assertNumber(bits);\n  if (typeof chr !== 'string') throw new Error('padding chr should be string');\n  return {\n    encode(data) {\n      if (!Array.isArray(data) || data.length && typeof data[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n      for (let i of data) if (typeof i !== 'string') throw new Error(`padding.encode: non-string input=${i}`);\n      while (data.length * bits % 8) data.push(chr);\n      return data;\n    },\n    decode(input) {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n      for (let i of input) if (typeof i !== 'string') throw new Error(`padding.decode: non-string input=${i}`);\n      let end = input.length;\n      if (end * bits % 8) throw new Error('Invalid padding: string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        if (!((end - 1) * bits % 8)) throw new Error('Invalid padding: string has too much padding');\n      }\n      return input.slice(0, end);\n    }\n  };\n}\nfunction normalize(fn) {\n  if (typeof fn !== 'function') throw new Error('normalize fn should be function');\n  return {\n    encode: from => from,\n    decode: to => fn(to)\n  };\n}\nfunction convertRadix(data, from, to) {\n  if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n  if (!Array.isArray(data)) throw new Error('convertRadix: data should be array');\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data);\n  digits.forEach(d => {\n    assertNumber(d);\n    if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n  });\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < digits.length; i++) {\n      const digit = digits[i];\n      const digitBase = from * carry + digit;\n      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      carry = digitBase % to;\n      digits[i] = Math.floor(digitBase / to);\n      if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');\n      if (!done) continue;else if (!digits[i]) pos = i;else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\nconst gcd = (a, b) => !b ? a : gcd(b, a % b);\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n  if (!Array.isArray(data)) throw new Error('convertRadix2: data should be array');\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n  }\n  let carry = 0;\n  let pos = 0;\n  const mask = 2 ** to - 1;\n  const res = [];\n  for (const n of data) {\n    assertNumber(n);\n    if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = carry << from | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push((carry >> pos - to & mask) >>> 0);\n    carry &= 2 ** pos - 1;\n  }\n  carry = carry << to - pos & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\nfunction radix(num) {\n  assertNumber(num);\n  return {\n    encode: bytes => {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), 2 ** 8, num);\n    },\n    decode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix.decode input should be array of strings');\n      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n    }\n  };\n}\nfunction radix2(bits, revPadding = false) {\n  assertNumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');\n  return {\n    encode: bytes => {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: digits => {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix2.decode input should be array of strings');\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    }\n  };\n}\nfunction unsafeWrapper(fn) {\n  if (typeof fn !== 'function') throw new Error('unsafeWrapper fn should be function');\n  return function (...args) {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\nfunction checksum(len, fn) {\n  assertNumber(len);\n  if (typeof fn !== 'function') throw new Error('checksum fn should be function');\n  return {\n    encode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.encode: input should be Uint8Array');\n      const checksum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(checksum, data.length);\n      return res;\n    },\n    decode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const newChecksum = fn(payload).slice(0, len);\n      const oldChecksum = data.slice(-len);\n      for (let i = 0; i < len; i++) if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    }\n  };\n}\nconst utils = {\n  alphabet,\n  chain,\n  checksum,\n  radix,\n  radix2,\n  join,\n  padding\n};\nconst base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nconst base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nconst base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nconst base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize(s => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nconst base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nconst base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = abc => chain(radix(58), alphabet(abc), join(''));\nconst base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nconst base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nconst base58xmr = {\n  encode(data) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n    }\n    return res;\n  },\n  decode(str) {\n    let res = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  }\n};\nconst base58check = sha256 => chain(checksum(4, data => sha256(sha256(data))), base58);\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n  }\n  return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ c >> 5;\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n  function encode(prefix, words, limit = 90) {\n    if (typeof prefix !== 'string') throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n    if (!Array.isArray(words) || words.length && typeof words[0] !== 'number') throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n    const actualLength = prefix.length + 7 + words.length;\n    if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    prefix = prefix.toLowerCase();\n    return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n  }\n  function decode(str, limit = 90) {\n    if (typeof str !== 'string') throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n    if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n    str = lowered;\n    const sepIndex = str.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = str.slice(0, sepIndex);\n    const _words = str.slice(sepIndex + 1);\n    if (_words.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!_words.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return {\n      prefix,\n      words\n    };\n  }\n  const decodeUnsafe = unsafeWrapper(decode);\n  function decodeToBytes(str) {\n    const {\n      prefix,\n      words\n    } = decode(str, false);\n    return {\n      prefix,\n      words,\n      bytes: fromWords(words)\n    };\n  }\n  return {\n    encode,\n    decode,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords\n  };\n}\nconst bech32 = genBech32('bech32');\nconst bech32m = genBech32('bech32m');\nconst utf8 = {\n  encode: data => new TextDecoder().decode(data),\n  decode: str => new TextEncoder().encode(str)\n};\nconst hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize(s => {\n  if (typeof s !== 'string' || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n  return s.toLowerCase();\n}));\nconst CODERS = {\n  utf8,\n  hex,\n  base16,\n  base32,\n  base64,\n  base64url,\n  base58,\n  base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nconst bytesToString = (type, bytes) => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!(bytes instanceof Uint8Array)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\nconst str = bytesToString;\nconst stringToBytes = (type, str) => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/base/lib/esm/index.js?");

/***/ }),

/***/ "./node_modules/@scure/bip32/lib/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@scure/bip32/lib/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HARDENED_OFFSET\": () => (/* binding */ HARDENED_OFFSET),\n/* harmony export */   \"HDKey\": () => (/* binding */ HDKey)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/_assert */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @scure/base */ \"./node_modules/@scure/base/lib/esm/index.js\");\n\n\n\n\n\n\n\n\n\nconst Point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_6__.secp256k1.ProjectivePoint;\nconst base58check = (0,_scure_base__WEBPACK_IMPORTED_MODULE_8__.base58check)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\nfunction bytesToNumber(bytes) {\n  return BigInt(`0x${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_5__.bytesToHex)(bytes)}`);\n}\nfunction numberToBytes(num) {\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_5__.hexToBytes)(num.toString(16).padStart(64, '0'));\n}\nconst MASTER_SECRET = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_5__.utf8ToBytes)('Bitcoin seed');\nconst BITCOIN_VERSIONS = {\n  private: 0x0488ade4,\n  public: 0x0488b21e\n};\nconst HARDENED_OFFSET = 0x80000000;\nconst hash160 = data => (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_1__.ripemd160)((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(data));\nconst fromU32 = data => (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_5__.createView)(data).getUint32(0, false);\nconst toU32 = n => {\n  if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n    throw new Error(`Invalid number=${n}. Should be from 0 to 2 ** 32 - 1`);\n  }\n  const buf = new Uint8Array(4);\n  (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_5__.createView)(buf).setUint32(0, n, false);\n  return buf;\n};\nclass HDKey {\n  get fingerprint() {\n    if (!this.pubHash) {\n      throw new Error('No publicKey set!');\n    }\n    return fromU32(this.pubHash);\n  }\n  get identifier() {\n    return this.pubHash;\n  }\n  get pubKeyHash() {\n    return this.pubHash;\n  }\n  get privateKey() {\n    return this.privKeyBytes || null;\n  }\n  get publicKey() {\n    return this.pubKey || null;\n  }\n  get privateExtendedKey() {\n    const priv = this.privateKey;\n    if (!priv) {\n      throw new Error('No private key');\n    }\n    return base58check.encode(this.serialize(this.versions.private, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_5__.concatBytes)(new Uint8Array([0]), priv)));\n  }\n  get publicExtendedKey() {\n    if (!this.pubKey) {\n      throw new Error('No public key');\n    }\n    return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n  }\n  static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {\n    (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_4__.bytes)(seed);\n    if (8 * seed.length < 128 || 8 * seed.length > 512) {\n      throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);\n    }\n    const I = (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_3__.sha512, MASTER_SECRET, seed);\n    return new HDKey({\n      versions,\n      chainCode: I.slice(32),\n      privateKey: I.slice(0, 32)\n    });\n  }\n  static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {\n    const keyBuffer = base58check.decode(base58key);\n    const keyView = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_5__.createView)(keyBuffer);\n    const version = keyView.getUint32(0, false);\n    const opt = {\n      versions,\n      depth: keyBuffer[4],\n      parentFingerprint: keyView.getUint32(5, false),\n      index: keyView.getUint32(9, false),\n      chainCode: keyBuffer.slice(13, 45)\n    };\n    const key = keyBuffer.slice(45);\n    const isPriv = key[0] === 0;\n    if (version !== versions[isPriv ? 'private' : 'public']) {\n      throw new Error('Version mismatch');\n    }\n    if (isPriv) {\n      return new HDKey({\n        ...opt,\n        privateKey: key.slice(1)\n      });\n    } else {\n      return new HDKey({\n        ...opt,\n        publicKey: key\n      });\n    }\n  }\n  static fromJSON(json) {\n    return HDKey.fromExtendedKey(json.xpriv);\n  }\n  constructor(opt) {\n    this.depth = 0;\n    this.index = 0;\n    this.chainCode = null;\n    this.parentFingerprint = 0;\n    if (!opt || typeof opt !== 'object') {\n      throw new Error('HDKey.constructor must not be called directly');\n    }\n    this.versions = opt.versions || BITCOIN_VERSIONS;\n    this.depth = opt.depth || 0;\n    this.chainCode = opt.chainCode;\n    this.index = opt.index || 0;\n    this.parentFingerprint = opt.parentFingerprint || 0;\n    if (!this.depth) {\n      if (this.parentFingerprint || this.index) {\n        throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n      }\n    }\n    if (opt.publicKey && opt.privateKey) {\n      throw new Error('HDKey: publicKey and privateKey at same time.');\n    }\n    if (opt.privateKey) {\n      if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_6__.secp256k1.utils.isValidPrivateKey(opt.privateKey)) {\n        throw new Error('Invalid private key');\n      }\n      this.privKey = typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);\n      this.privKeyBytes = numberToBytes(this.privKey);\n      this.pubKey = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_6__.secp256k1.getPublicKey(opt.privateKey, true);\n    } else if (opt.publicKey) {\n      this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true);\n    } else {\n      throw new Error('HDKey: no public or private key provided');\n    }\n    this.pubHash = hash160(this.pubKey);\n  }\n  derive(path) {\n    if (!/^[mM]'?/.test(path)) {\n      throw new Error('Path must start with \"m\" or \"M\"');\n    }\n    if (/^[mM]'?$/.test(path)) {\n      return this;\n    }\n    const parts = path.replace(/^[mM]'?\\//, '').split('/');\n    let child = this;\n    for (const c of parts) {\n      const m = /^(\\d+)('?)$/.exec(c);\n      if (!m || m.length !== 3) {\n        throw new Error(`Invalid child index: ${c}`);\n      }\n      let idx = +m[1];\n      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n        throw new Error('Invalid index');\n      }\n      if (m[2] === \"'\") {\n        idx += HARDENED_OFFSET;\n      }\n      child = child.deriveChild(idx);\n    }\n    return child;\n  }\n  deriveChild(index) {\n    if (!this.pubKey || !this.chainCode) {\n      throw new Error('No publicKey or chainCode set');\n    }\n    let data = toU32(index);\n    if (index >= HARDENED_OFFSET) {\n      const priv = this.privateKey;\n      if (!priv) {\n        throw new Error('Could not derive hardened child key');\n      }\n      data = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_5__.concatBytes)(new Uint8Array([0]), priv, data);\n    } else {\n      data = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_5__.concatBytes)(this.pubKey, data);\n    }\n    const I = (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_3__.sha512, this.chainCode, data);\n    const childTweak = bytesToNumber(I.slice(0, 32));\n    const chainCode = I.slice(32);\n    if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_6__.secp256k1.utils.isValidPrivateKey(childTweak)) {\n      throw new Error('Tweak bigger than curve order');\n    }\n    const opt = {\n      versions: this.versions,\n      chainCode,\n      depth: this.depth + 1,\n      parentFingerprint: this.fingerprint,\n      index\n    };\n    try {\n      if (this.privateKey) {\n        const added = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_7__.mod)(this.privKey + childTweak, _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_6__.secp256k1.CURVE.n);\n        if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_6__.secp256k1.utils.isValidPrivateKey(added)) {\n          throw new Error('The tweak was out of range or the resulted private key is invalid');\n        }\n        opt.privateKey = added;\n      } else {\n        const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n        if (added.equals(Point.ZERO)) {\n          throw new Error('The tweak was equal to negative P, which made the result key invalid');\n        }\n        opt.publicKey = added.toRawBytes(true);\n      }\n      return new HDKey(opt);\n    } catch (err) {\n      return this.deriveChild(index + 1);\n    }\n  }\n  sign(hash) {\n    if (!this.privateKey) {\n      throw new Error('No privateKey set!');\n    }\n    (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_4__.bytes)(hash, 32);\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_6__.secp256k1.sign(hash, this.privKey).toCompactRawBytes();\n  }\n  verify(hash, signature) {\n    (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_4__.bytes)(hash, 32);\n    (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_4__.bytes)(signature, 64);\n    if (!this.publicKey) {\n      throw new Error('No publicKey set!');\n    }\n    let sig;\n    try {\n      sig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_6__.secp256k1.Signature.fromCompact(signature);\n    } catch (error) {\n      return false;\n    }\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_6__.secp256k1.verify(sig, hash, this.publicKey);\n  }\n  wipePrivateData() {\n    this.privKey = undefined;\n    if (this.privKeyBytes) {\n      this.privKeyBytes.fill(0);\n      this.privKeyBytes = undefined;\n    }\n    return this;\n  }\n  toJSON() {\n    return {\n      xpriv: this.privateExtendedKey,\n      xpub: this.publicExtendedKey\n    };\n  }\n  serialize(version, key) {\n    if (!this.chainCode) {\n      throw new Error('No chainCode set');\n    }\n    (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_4__.bytes)(key, 33);\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_5__.concatBytes)(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);\n  }\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip32/lib/esm/index.js?");

/***/ }),

/***/ "./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bool\": () => (/* binding */ bool),\n/* harmony export */   \"bytes\": () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"exists\": () => (/* binding */ exists),\n/* harmony export */   \"hash\": () => (/* binding */ hash),\n/* harmony export */   \"number\": () => (/* binding */ number),\n/* harmony export */   \"output\": () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n  if (!(b instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length)) throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\nconst assert = {\n  number,\n  bool,\n  bytes,\n  hash,\n  exists,\n  output\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js?");

/***/ }),

/***/ "./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SHA2\": () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number(value >> _32n & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n  constructor(blockLen, outputLen, padOffset, isLE) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.finished = false;\n    this.length = 0;\n    this.pos = 0;\n    this.destroyed = false;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(this.buffer);\n  }\n  update(data) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n    const {\n      view,\n      buffer,\n      blockLen\n    } = this;\n    data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n    const len = data.length;\n    for (let pos = 0; pos < len;) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const {\n      buffer,\n      view,\n      blockLen,\n      isLE\n    } = this;\n    let {\n      pos\n    } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const {\n      buffer,\n      outputLen\n    } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to) {\n    to || (to = new this.constructor());\n    to.set(...this.get());\n    const {\n      blockLen,\n      buffer,\n      length,\n      finished,\n      destroyed,\n      pos\n    } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js?");

/***/ }),

/***/ "./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"fromBig\": () => (/* binding */ fromBig),\n/* harmony export */   \"split\": () => (/* binding */ split),\n/* harmony export */   \"toBig\": () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n  if (le) return {\n    h: Number(n & U32_MASK64),\n    l: Number(n >> _32n & U32_MASK64)\n  };\n  return {\n    h: Number(n >> _32n & U32_MASK64) | 0,\n    l: Number(n & U32_MASK64) | 0\n  };\n}\nfunction split(lst, le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const {\n      h,\n      l\n    } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\nconst toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, l, s) => h >>> s;\nconst shrSL = (h, l, s) => h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s) => h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h, l) => l;\nconst rotr32L = (h, l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s) => l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nfunction add(Ah, Al, Bh, Bl) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return {\n    h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n    l: l | 0\n  };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\nconst u64 = {\n  fromBig,\n  split,\n  toBig,\n  shrSH,\n  shrSL,\n  rotrSH,\n  rotrSL,\n  rotrBH,\n  rotrBL,\n  rotr32H,\n  rotr32L,\n  rotlSH,\n  rotlSL,\n  rotlBH,\n  rotlBL,\n  add,\n  add3L,\n  add3H,\n  add4L,\n  add4H,\n  add5H,\n  add5L\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js?");

/***/ }),

/***/ "./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/crypto.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/crypto.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"crypto\": () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/crypto.js?");

/***/ }),

/***/ "./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hmac\": () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n  constructor(hash, _key) {\n    super();\n    this.finished = false;\n    this.destroyed = false;\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n    const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_key);\n    this.iHash = hash.create();\n    if (typeof this.iHash.update !== 'function') throw new TypeError('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create();\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to) {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to || (to = Object.create(Object.getPrototypeOf(this), {}));\n    const {\n      oHash,\n      iHash,\n      finished,\n      destroyed,\n      blockLen,\n      outputLen\n    } = this;\n    to = to;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js?");

/***/ }),

/***/ "./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RIPEMD160\": () => (/* binding */ RIPEMD160),\n/* harmony export */   \"ripemd160\": () => (/* binding */ ripemd160)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = Uint8Array.from({\n  length: 16\n}, (_, i) => i);\nconst Pi = Id.map(i => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++) for (let j of [idxL, idxR]) j.push(j[i].map(k => Rho[k]));\nconst shifts = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map(i => new Uint8Array(i));\nconst shiftsL = idxL.map((idx, i) => idx.map(j => shifts[i][j]));\nconst shiftsR = idxR.map((idx, i) => idx.map(j => shifts[i][j]));\nconst Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);\nconst Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => word << shift | word >>> 32 - shift;\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n  if (group === 0) return x ^ y ^ z;else if (group === 1) return x & y | ~x & z;else if (group === 2) return (x | ~y) ^ z;else if (group === 3) return x & z | y & ~z;else return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = new Uint32Array(16);\nclass RIPEMD160 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n  constructor() {\n    super(64, 20, 8, true);\n    this.h0 = 0x67452301 | 0;\n    this.h1 = 0xefcdab89 | 0;\n    this.h2 = 0x98badcfe | 0;\n    this.h3 = 0x10325476 | 0;\n    this.h4 = 0xc3d2e1f0 | 0;\n  }\n  get() {\n    const {\n      h0,\n      h1,\n      h2,\n      h3,\n      h4\n    } = this;\n    return [h0, h1, h2, h3, h4];\n  }\n  set(h0, h1, h2, h3, h4) {\n    this.h0 = h0 | 0;\n    this.h1 = h1 | 0;\n    this.h2 = h2 | 0;\n    this.h3 = h3 | 0;\n    this.h4 = h4 | 0;\n  }\n  process(view, offset) {\n    for (let i = 0; i < 16; i++, offset += 4) BUF[i] = view.getUint32(offset, true);\n    // prettier-ignore\n    let al = this.h0 | 0,\n      ar = al,\n      bl = this.h1 | 0,\n      br = bl,\n      cl = this.h2 | 0,\n      cr = cl,\n      dl = this.h3 | 0,\n      dr = dl,\n      el = this.h4 | 0,\n      er = el;\n    // Instead of iterating 0 to 80, we split it into 5 groups\n    // And use the groups in constants, functions, etc. Much simpler\n    for (let group = 0; group < 5; group++) {\n      const rGroup = 4 - group;\n      const hbl = Kl[group],\n        hbr = Kr[group]; // prettier-ignore\n      const rl = idxL[group],\n        rr = idxR[group]; // prettier-ignore\n      const sl = shiftsL[group],\n        sr = shiftsR[group]; // prettier-ignore\n      for (let i = 0; i < 16; i++) {\n        const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;\n        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n      }\n      // 2 loops are 10% faster\n      for (let i = 0; i < 16; i++) {\n        const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;\n        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n      }\n    }\n    // Add the compressed chunk to the current hash value\n    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);\n  }\n  roundClean() {\n    BUF.fill(0);\n  }\n  destroy() {\n    this.destroyed = true;\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0);\n  }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nconst ripemd160 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new RIPEMD160());\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js?");

/***/ }),

/***/ "./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"sha224\": () => (/* binding */ sha224),\n/* harmony export */   \"sha256\": () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Choice: a ? b : c\nconst Chi = (a, b, c) => a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => a & b ^ a & c ^ b & c;\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n  constructor() {\n    super(64, 32, 8, false);\n    // We cannot use array here since array allows indexing by variable\n    // which means optimizer/compiler cannot use registers.\n    this.A = IV[0] | 0;\n    this.B = IV[1] | 0;\n    this.C = IV[2] | 0;\n    this.D = IV[3] | 0;\n    this.E = IV[4] | 0;\n    this.F = IV[5] | 0;\n    this.G = IV[6] | 0;\n    this.H = IV[7] | 0;\n  }\n  get() {\n    const {\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H\n    } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  set(A, B, C, D, E, F, G, H) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  process(view, offset) {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ W15 >>> 3;\n      const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ W2 >>> 10;\n      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let {\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H\n    } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n      const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n      const T2 = sigma0 + Maj(A, B, C) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = D + T1 | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = T1 + T2 | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = A + this.A | 0;\n    B = B + this.B | 0;\n    C = C + this.C | 0;\n    D = D + this.D | 0;\n    E = E + this.E | 0;\n    F = F + this.F | 0;\n    G = G + this.G | 0;\n    H = H + this.H | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  constructor() {\n    super();\n    this.A = 0xc1059ed8 | 0;\n    this.B = 0x367cd507 | 0;\n    this.C = 0x3070dd17 | 0;\n    this.D = 0xf70e5939 | 0;\n    this.E = 0xffc00b31 | 0;\n    this.F = 0x68581511 | 0;\n    this.G = 0x64f98fa7 | 0;\n    this.H = 0xbefa4fa4 | 0;\n    this.outputLen = 28;\n  }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js?");

/***/ }),

/***/ "./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SHA512\": () => (/* binding */ SHA512),\n/* harmony export */   \"sha384\": () => (/* binding */ sha384),\n/* harmony export */   \"sha512\": () => (/* binding */ sha512),\n/* harmony export */   \"sha512_224\": () => (/* binding */ sha512_224),\n/* harmony export */   \"sha512_256\": () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_u64.js */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].split(['0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc', '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118', '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2', '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694', '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65', '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5', '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4', '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70', '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df', '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b', '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30', '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8', '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8', '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3', '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec', '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b', '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178', '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b', '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c', '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'].map(n => BigInt(n)));\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = new Uint32Array(80);\nconst SHA512_W_L = new Uint32Array(80);\nclass SHA512 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n  constructor() {\n    super(128, 64, 16, false);\n    // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n    // Also looks cleaner and easier to verify with spec.\n    // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n    // h -- high 32 bits, l -- low 32 bits\n    this.Ah = 0x6a09e667 | 0;\n    this.Al = 0xf3bcc908 | 0;\n    this.Bh = 0xbb67ae85 | 0;\n    this.Bl = 0x84caa73b | 0;\n    this.Ch = 0x3c6ef372 | 0;\n    this.Cl = 0xfe94f82b | 0;\n    this.Dh = 0xa54ff53a | 0;\n    this.Dl = 0x5f1d36f1 | 0;\n    this.Eh = 0x510e527f | 0;\n    this.El = 0xade682d1 | 0;\n    this.Fh = 0x9b05688c | 0;\n    this.Fl = 0x2b3e6c1f | 0;\n    this.Gh = 0x1f83d9ab | 0;\n    this.Gl = 0xfb41bd6b | 0;\n    this.Hh = 0x5be0cd19 | 0;\n    this.Hl = 0x137e2179 | 0;\n  }\n  // prettier-ignore\n  get() {\n    const {\n      Ah,\n      Al,\n      Bh,\n      Bl,\n      Ch,\n      Cl,\n      Dh,\n      Dl,\n      Eh,\n      El,\n      Fh,\n      Fl,\n      Gh,\n      Gl,\n      Hh,\n      Hl\n    } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  process(view, offset) {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32(offset += 4);\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shrSH(W15h, W15l, 7);\n      const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shrSH(W2h, W2l, 6);\n      const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let {\n      Ah,\n      Al,\n      Bh,\n      Bl,\n      Ch,\n      Cl,\n      Dh,\n      Dl,\n      Eh,\n      El,\n      Fh,\n      Fl,\n      Gh,\n      Gl,\n      Hh,\n      Hl\n    } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBH(Eh, El, 41);\n      const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = Eh & Fh ^ ~Eh & Gh;\n      const CHIl = El & Fl ^ ~El & Gl;\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBH(Ah, Al, 39);\n      const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBL(Ah, Al, 39);\n      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({\n        h: Eh,\n        l: El\n      } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add3L(T1l, sigma0l, MAJl);\n      Ah = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({\n      h: Ah,\n      l: Al\n    } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({\n      h: Bh,\n      l: Bl\n    } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({\n      h: Ch,\n      l: Cl\n    } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({\n      h: Dh,\n      l: Dl\n    } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({\n      h: Eh,\n      l: El\n    } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({\n      h: Fh,\n      l: Fl\n    } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({\n      h: Gh,\n      l: Gl\n    } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({\n      h: Hh,\n      l: Hl\n    } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  roundClean() {\n    SHA512_W_H.fill(0);\n    SHA512_W_L.fill(0);\n  }\n  destroy() {\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\nclass SHA512_224 extends SHA512 {\n  constructor() {\n    super();\n    // h -- high 32 bits, l -- low 32 bits\n    this.Ah = 0x8c3d37c8 | 0;\n    this.Al = 0x19544da2 | 0;\n    this.Bh = 0x73e19966 | 0;\n    this.Bl = 0x89dcd4d6 | 0;\n    this.Ch = 0x1dfab7ae | 0;\n    this.Cl = 0x32ff9c82 | 0;\n    this.Dh = 0x679dd514 | 0;\n    this.Dl = 0x582f9fcf | 0;\n    this.Eh = 0x0f6d2b69 | 0;\n    this.El = 0x7bd44da8 | 0;\n    this.Fh = 0x77e36f73 | 0;\n    this.Fl = 0x04c48942 | 0;\n    this.Gh = 0x3f9d85a8 | 0;\n    this.Gl = 0x6a1d36c8 | 0;\n    this.Hh = 0x1112e6ad | 0;\n    this.Hl = 0x91d692a1 | 0;\n    this.outputLen = 28;\n  }\n}\nclass SHA512_256 extends SHA512 {\n  constructor() {\n    super();\n    // h -- high 32 bits, l -- low 32 bits\n    this.Ah = 0x22312194 | 0;\n    this.Al = 0xfc2bf72c | 0;\n    this.Bh = 0x9f555fa3 | 0;\n    this.Bl = 0xc84c64c2 | 0;\n    this.Ch = 0x2393b86b | 0;\n    this.Cl = 0x6f53b151 | 0;\n    this.Dh = 0x96387719 | 0;\n    this.Dl = 0x5940eabd | 0;\n    this.Eh = 0x96283ee2 | 0;\n    this.El = 0xa88effe3 | 0;\n    this.Fh = 0xbe5e1e25 | 0;\n    this.Fl = 0x53863992 | 0;\n    this.Gh = 0x2b0199fc | 0;\n    this.Gl = 0x2c85b8aa | 0;\n    this.Hh = 0x0eb72ddc | 0;\n    this.Hl = 0x81c52ca2 | 0;\n    this.outputLen = 32;\n  }\n}\nclass SHA384 extends SHA512 {\n  constructor() {\n    super();\n    // h -- high 32 bits, l -- low 32 bits\n    this.Ah = 0xcbbb9d5d | 0;\n    this.Al = 0xc1059ed8 | 0;\n    this.Bh = 0x629a292a | 0;\n    this.Bl = 0x367cd507 | 0;\n    this.Ch = 0x9159015a | 0;\n    this.Cl = 0x3070dd17 | 0;\n    this.Dh = 0x152fecd8 | 0;\n    this.Dl = 0xf70e5939 | 0;\n    this.Eh = 0x67332667 | 0;\n    this.El = 0xffc00b31 | 0;\n    this.Fh = 0x8eb44a87 | 0;\n    this.Fl = 0x68581511 | 0;\n    this.Gh = 0xdb0c2e0d | 0;\n    this.Gl = 0x64f98fa7 | 0;\n    this.Hh = 0x47b5481d | 0;\n    this.Hl = 0xbefa4fa4 | 0;\n    this.outputLen = 48;\n  }\n}\nconst sha512 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js?");

/***/ }),

/***/ "./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Hash\": () => (/* binding */ Hash),\n/* harmony export */   \"asyncLoop\": () => (/* binding */ asyncLoop),\n/* harmony export */   \"bytesToHex\": () => (/* binding */ bytesToHex),\n/* harmony export */   \"checkOpts\": () => (/* binding */ checkOpts),\n/* harmony export */   \"concatBytes\": () => (/* binding */ concatBytes),\n/* harmony export */   \"createView\": () => (/* binding */ createView),\n/* harmony export */   \"hexToBytes\": () => (/* binding */ hexToBytes),\n/* harmony export */   \"isLE\": () => (/* binding */ isLE),\n/* harmony export */   \"nextTick\": () => (/* binding */ nextTick),\n/* harmony export */   \"randomBytes\": () => (/* binding */ randomBytes),\n/* harmony export */   \"rotr\": () => (/* binding */ rotr),\n/* harmony export */   \"toBytes\": () => (/* binding */ toBytes),\n/* harmony export */   \"u32\": () => (/* binding */ u32),\n/* harmony export */   \"u8\": () => (/* binding */ u8),\n/* harmony export */   \"utf8ToBytes\": () => (/* binding */ utf8ToBytes),\n/* harmony export */   \"wrapConstructor\": () => (/* binding */ wrapConstructor),\n/* harmony export */   \"wrapConstructorWithOpts\": () => (/* binding */ wrapConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use `globalThis.crypto`, but node.js versions earlier than v19 don't\n// declare it in global scope. For node.js, package.json#exports field mapping\n// rewrites import from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\n// Cast array to different type\nconst u8 = arr => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => word << 32 - shift | word >>> shift;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef])) // 'deadbeef'\n */\nfunction bytesToHex(uint8a) {\n  // pre-caching improves the speed 6x\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  let hex = '';\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n  return hex;\n}\n/**\n * @example hexToBytes('deadbeef') // Uint8Array.from([0xde, 0xad, 0xbe, 0xef])\n */\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  const array = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => {};\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\nfunction utf8ToBytes(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n  }\n  return new TextEncoder().encode(str);\n}\nfunction toBytes(data) {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!(data instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n  return data;\n}\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nfunction concatBytes(...arrays) {\n  if (!arrays.every(a => a instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\n// For runtime check if class implements interface\nclass Hash {\n  // Safe version that clones internal state\n  clone() {\n    return this._cloneInto();\n  }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = obj => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n  if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts))) throw new TypeError('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged;\n}\nfunction wrapConstructor(hashConstructor) {\n  const hashC = message => hashConstructor().update(toBytes(message)).digest();\n  const tmp = hashConstructor();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashConstructor();\n  return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({});\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = opts => hashCons(opts);\n  return hashC;\n}\n/**\n * Secure PRNG. Uses `globalThis.crypto` or node.js crypto module.\n */\nfunction randomBytes(bytesLength = 32) {\n  if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n    return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js?");

/***/ }),

/***/ "./node_modules/nostr-tools/lib/esm/nostr.mjs":
/*!****************************************************!*\
  !*** ./node_modules/nostr-tools/lib/esm/nostr.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Kind\": () => (/* binding */ Kind),\n/* harmony export */   \"SimplePool\": () => (/* binding */ SimplePool),\n/* harmony export */   \"finishEvent\": () => (/* binding */ finishEvent),\n/* harmony export */   \"fj\": () => (/* binding */ fakejson_exports),\n/* harmony export */   \"generatePrivateKey\": () => (/* binding */ generatePrivateKey),\n/* harmony export */   \"getBlankEvent\": () => (/* binding */ getBlankEvent),\n/* harmony export */   \"getEventHash\": () => (/* binding */ getEventHash),\n/* harmony export */   \"getPublicKey\": () => (/* binding */ getPublicKey),\n/* harmony export */   \"matchFilter\": () => (/* binding */ matchFilter),\n/* harmony export */   \"matchFilters\": () => (/* binding */ matchFilters),\n/* harmony export */   \"nip04\": () => (/* binding */ nip04_exports),\n/* harmony export */   \"nip05\": () => (/* binding */ nip05_exports),\n/* harmony export */   \"nip06\": () => (/* binding */ nip06_exports),\n/* harmony export */   \"nip19\": () => (/* binding */ nip19_exports),\n/* harmony export */   \"nip26\": () => (/* binding */ nip26_exports),\n/* harmony export */   \"nip39\": () => (/* binding */ nip39_exports),\n/* harmony export */   \"nip57\": () => (/* binding */ nip57_exports),\n/* harmony export */   \"relayInit\": () => (/* binding */ relayInit),\n/* harmony export */   \"serializeEvent\": () => (/* binding */ serializeEvent),\n/* harmony export */   \"signEvent\": () => (/* binding */ signEvent),\n/* harmony export */   \"utils\": () => (/* binding */ utils_exports),\n/* harmony export */   \"validateEvent\": () => (/* binding */ validateEvent),\n/* harmony export */   \"verifySignature\": () => (/* binding */ verifySignature)\n/* harmony export */ });\n/* harmony import */ var _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/secp256k1 */ \"./node_modules/@noble/secp256k1/lib/esm/index.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scure/base */ \"./node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _scure_bip39_wordlists_english_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @scure/bip39/wordlists/english.js */ \"./node_modules/@scure/bip39/wordlists/english.js\");\n/* harmony import */ var _scure_bip39__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @scure/bip39 */ \"./node_modules/@scure/bip39/index.js\");\n/* harmony import */ var _scure_bip32__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @scure/bip32 */ \"./node_modules/@scure/bip32/lib/esm/index.js\");\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/hashes/hmac */ \"./node_modules/@noble/hashes/esm/hmac.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// keys.ts\n\nfunction generatePrivateKey() {\n  return _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.bytesToHex(_noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.randomPrivateKey());\n}\nfunction getPublicKey(privateKey) {\n  return _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.bytesToHex(_noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.schnorr.getPublicKey(privateKey));\n}\n\n// event.ts\n\n\n\n// utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  insertEventIntoAscendingList: () => insertEventIntoAscendingList,\n  insertEventIntoDescendingList: () => insertEventIntoDescendingList,\n  normalizeURL: () => normalizeURL,\n  utf8Decoder: () => utf8Decoder,\n  utf8Encoder: () => utf8Encoder\n});\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nvar utf8Encoder = new TextEncoder();\nfunction normalizeURL(url) {\n  let p = new URL(url);\n  p.pathname = p.pathname.replace(/\\/+/g, \"/\");\n  if (p.pathname.endsWith(\"/\"))\n    p.pathname = p.pathname.slice(0, -1);\n  if (p.port === \"80\" && p.protocol === \"ws:\" || p.port === \"443\" && p.protocol === \"wss:\")\n    p.port = \"\";\n  p.searchParams.sort();\n  p.hash = \"\";\n  return p.toString();\n}\nfunction insertEventIntoDescendingList(sortedArray, event) {\n  let start = 0;\n  let end = sortedArray.length - 1;\n  let midPoint;\n  let position = start;\n  if (end < 0) {\n    position = 0;\n  } else if (event.created_at < sortedArray[end].created_at) {\n    position = end + 1;\n  } else if (event.created_at >= sortedArray[start].created_at) {\n    position = start;\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end;\n        break;\n      }\n      midPoint = Math.floor(start + (end - start) / 2);\n      if (sortedArray[midPoint].created_at > event.created_at) {\n        start = midPoint;\n      } else if (sortedArray[midPoint].created_at < event.created_at) {\n        end = midPoint;\n      } else {\n        position = midPoint;\n        break;\n      }\n    }\n  if (sortedArray[position]?.id !== event.id) {\n    return [\n      ...sortedArray.slice(0, position),\n      event,\n      ...sortedArray.slice(position)\n    ];\n  }\n  return sortedArray;\n}\nfunction insertEventIntoAscendingList(sortedArray, event) {\n  let start = 0;\n  let end = sortedArray.length - 1;\n  let midPoint;\n  let position = start;\n  if (end < 0) {\n    position = 0;\n  } else if (event.created_at > sortedArray[end].created_at) {\n    position = end + 1;\n  } else if (event.created_at <= sortedArray[start].created_at) {\n    position = start;\n  } else\n    while (true) {\n      if (end <= start + 1) {\n        position = end;\n        break;\n      }\n      midPoint = Math.floor(start + (end - start) / 2);\n      if (sortedArray[midPoint].created_at < event.created_at) {\n        start = midPoint;\n      } else if (sortedArray[midPoint].created_at > event.created_at) {\n        end = midPoint;\n      } else {\n        position = midPoint;\n        break;\n      }\n    }\n  if (sortedArray[position]?.id !== event.id) {\n    return [\n      ...sortedArray.slice(0, position),\n      event,\n      ...sortedArray.slice(position)\n    ];\n  }\n  return sortedArray;\n}\n\n// event.ts\nvar Kind = /* @__PURE__ */ ((Kind2) => {\n  Kind2[Kind2[\"Metadata\"] = 0] = \"Metadata\";\n  Kind2[Kind2[\"Text\"] = 1] = \"Text\";\n  Kind2[Kind2[\"RecommendRelay\"] = 2] = \"RecommendRelay\";\n  Kind2[Kind2[\"Contacts\"] = 3] = \"Contacts\";\n  Kind2[Kind2[\"EncryptedDirectMessage\"] = 4] = \"EncryptedDirectMessage\";\n  Kind2[Kind2[\"EventDeletion\"] = 5] = \"EventDeletion\";\n  Kind2[Kind2[\"Reaction\"] = 7] = \"Reaction\";\n  Kind2[Kind2[\"ChannelCreation\"] = 40] = \"ChannelCreation\";\n  Kind2[Kind2[\"ChannelMetadata\"] = 41] = \"ChannelMetadata\";\n  Kind2[Kind2[\"ChannelMessage\"] = 42] = \"ChannelMessage\";\n  Kind2[Kind2[\"ChannelHideMessage\"] = 43] = \"ChannelHideMessage\";\n  Kind2[Kind2[\"ChannelMuteUser\"] = 44] = \"ChannelMuteUser\";\n  Kind2[Kind2[\"Report\"] = 1984] = \"Report\";\n  Kind2[Kind2[\"ZapRequest\"] = 9734] = \"ZapRequest\";\n  Kind2[Kind2[\"Zap\"] = 9735] = \"Zap\";\n  Kind2[Kind2[\"RelayList\"] = 10002] = \"RelayList\";\n  Kind2[Kind2[\"ClientAuth\"] = 22242] = \"ClientAuth\";\n  Kind2[Kind2[\"Article\"] = 30023] = \"Article\";\n  return Kind2;\n})(Kind || {});\nfunction getBlankEvent() {\n  return {\n    kind: 255,\n    content: \"\",\n    tags: [],\n    created_at: 0\n  };\n}\nfunction finishEvent(t, privateKey) {\n  let event = t;\n  event.pubkey = getPublicKey(privateKey);\n  event.id = getEventHash(event);\n  event.sig = signEvent(event, privateKey);\n  return event;\n}\nfunction serializeEvent(evt) {\n  if (!validateEvent(evt))\n    throw new Error(\"can't serialize event with wrong or missing properties\");\n  return JSON.stringify([\n    0,\n    evt.pubkey,\n    evt.created_at,\n    evt.kind,\n    evt.tags,\n    evt.content\n  ]);\n}\nfunction getEventHash(event) {\n  let eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(serializeEvent(event)));\n  return _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.bytesToHex(eventHash);\n}\nfunction validateEvent(event) {\n  if (typeof event !== \"object\")\n    return false;\n  if (typeof event.kind !== \"number\")\n    return false;\n  if (typeof event.content !== \"string\")\n    return false;\n  if (typeof event.created_at !== \"number\")\n    return false;\n  if (typeof event.pubkey !== \"string\")\n    return false;\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/))\n    return false;\n  if (!Array.isArray(event.tags))\n    return false;\n  for (let i = 0; i < event.tags.length; i++) {\n    let tag = event.tags[i];\n    if (!Array.isArray(tag))\n      return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\")\n        return false;\n    }\n  }\n  return true;\n}\nfunction verifySignature(event) {\n  return _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.schnorr.verifySync(\n    event.sig,\n    getEventHash(event),\n    event.pubkey\n  );\n}\nfunction signEvent(event, key) {\n  return _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.bytesToHex(\n    _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.schnorr.signSync(getEventHash(event), key)\n  );\n}\n\n// filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1)\n    return false;\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1)\n    return false;\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1)\n    return false;\n  for (let f in filter) {\n    if (f[0] === \"#\") {\n      let tagName = f.slice(1);\n      let values = filter[`#${tagName}`];\n      if (values && !event.tags.find(\n        ([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1\n      ))\n        return false;\n    }\n  }\n  if (filter.since && event.created_at < filter.since)\n    return false;\n  if (filter.until && event.created_at >= filter.until)\n    return false;\n  return true;\n}\nfunction matchFilters(filters, event) {\n  for (let i = 0; i < filters.length; i++) {\n    if (matchFilter(filters[i], event))\n      return true;\n  }\n  return false;\n}\n\n// fakejson.ts\nvar fakejson_exports = {};\n__export(fakejson_exports, {\n  getHex64: () => getHex64,\n  getInt: () => getInt,\n  getSubscriptionId: () => getSubscriptionId,\n  matchEventId: () => matchEventId,\n  matchEventKind: () => matchEventKind,\n  matchEventPubkey: () => matchEventPubkey\n});\nfunction getHex64(json, field) {\n  let len = field.length + 3;\n  let idx = json.indexOf(`\"${field}\":`) + len;\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1;\n  return json.slice(s, s + 64);\n}\nfunction getInt(json, field) {\n  let len = field.length;\n  let idx = json.indexOf(`\"${field}\":`) + len + 3;\n  let sliced = json.slice(idx);\n  let end = Math.min(sliced.indexOf(\",\"), sliced.indexOf(\"}\"));\n  return parseInt(sliced.slice(0, end), 10);\n}\nfunction getSubscriptionId(json) {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`);\n  if (idx === -1)\n    return null;\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`);\n  if (pstart === -1)\n    return null;\n  let start = idx + 7 + 1 + pstart;\n  let pend = json.slice(start + 1, 80).indexOf(`\"`);\n  if (pend === -1)\n    return null;\n  let end = start + 1 + pend;\n  return json.slice(start + 1, end);\n}\nfunction matchEventId(json, id) {\n  return id === getHex64(json, \"id\");\n}\nfunction matchEventPubkey(json, pubkey) {\n  return pubkey === getHex64(json, \"pubkey\");\n}\nfunction matchEventKind(json, kind) {\n  return kind === getInt(json, \"kind\");\n}\n\n// relay.ts\nfunction relayInit(url, options = {}) {\n  let { listTimeout = 3e3, getTimeout = 3e3 } = options;\n  var ws;\n  var openSubs = {};\n  var listeners = {\n    connect: [],\n    disconnect: [],\n    error: [],\n    notice: []\n  };\n  var subListeners = {};\n  var pubListeners = {};\n  async function connectRelay() {\n    return new Promise((resolve, reject) => {\n      try {\n        ws = new WebSocket(url);\n      } catch (err) {\n        reject(err);\n      }\n      ws.onopen = () => {\n        listeners.connect.forEach((cb) => cb());\n        resolve();\n      };\n      ws.onerror = () => {\n        listeners.error.forEach((cb) => cb());\n        reject();\n      };\n      ws.onclose = async () => {\n        listeners.disconnect.forEach((cb) => cb());\n      };\n      let incomingMessageQueue = [];\n      let handleNextInterval;\n      ws.onmessage = (e) => {\n        incomingMessageQueue.push(e.data);\n        if (!handleNextInterval) {\n          handleNextInterval = setInterval(handleNext, 0);\n        }\n      };\n      function handleNext() {\n        if (incomingMessageQueue.length === 0) {\n          clearInterval(handleNextInterval);\n          handleNextInterval = null;\n          return;\n        }\n        var json = incomingMessageQueue.shift();\n        if (!json)\n          return;\n        let subid = getSubscriptionId(json);\n        if (subid) {\n          let so = openSubs[subid];\n          if (so && so.alreadyHaveEvent && so.alreadyHaveEvent(getHex64(json, \"id\"), url)) {\n            return;\n          }\n        }\n        try {\n          let data = JSON.parse(json);\n          switch (data[0]) {\n            case \"EVENT\":\n              let id = data[1];\n              let event = data[2];\n              if (validateEvent(event) && openSubs[id] && (openSubs[id].skipVerification || verifySignature(event)) && matchFilters(openSubs[id].filters, event)) {\n                openSubs[id];\n                (subListeners[id]?.event || []).forEach((cb) => cb(event));\n              }\n              return;\n            case \"EOSE\": {\n              let id2 = data[1];\n              if (id2 in subListeners) {\n                subListeners[id2].eose.forEach((cb) => cb());\n                subListeners[id2].eose = [];\n              }\n              return;\n            }\n            case \"OK\": {\n              let id2 = data[1];\n              let ok = data[2];\n              let reason = data[3] || \"\";\n              if (id2 in pubListeners) {\n                if (ok)\n                  pubListeners[id2].ok.forEach((cb) => cb());\n                else\n                  pubListeners[id2].failed.forEach((cb) => cb(reason));\n                pubListeners[id2].ok = [];\n                pubListeners[id2].failed = [];\n              }\n              return;\n            }\n            case \"NOTICE\":\n              let notice = data[1];\n              listeners.notice.forEach((cb) => cb(notice));\n              return;\n          }\n        } catch (err) {\n          return;\n        }\n      }\n    });\n  }\n  function connected() {\n    return ws?.readyState === 1;\n  }\n  async function connect() {\n    if (connected())\n      return;\n    await connectRelay();\n  }\n  async function trySend(params) {\n    let msg = JSON.stringify(params);\n    if (!connected()) {\n      await new Promise((resolve) => setTimeout(resolve, 1e3));\n      if (!connected()) {\n        return;\n      }\n    }\n    try {\n      ws.send(msg);\n    } catch (err) {\n      console.log(err);\n    }\n  }\n  const sub = (filters, {\n    skipVerification = false,\n    alreadyHaveEvent = null,\n    id = Math.random().toString().slice(2)\n  } = {}) => {\n    let subid = id;\n    openSubs[subid] = {\n      id: subid,\n      filters,\n      skipVerification,\n      alreadyHaveEvent\n    };\n    trySend([\"REQ\", subid, ...filters]);\n    return {\n      sub: (newFilters, newOpts = {}) => sub(newFilters || filters, {\n        skipVerification: newOpts.skipVerification || skipVerification,\n        alreadyHaveEvent: newOpts.alreadyHaveEvent || alreadyHaveEvent,\n        id: subid\n      }),\n      unsub: () => {\n        delete openSubs[subid];\n        delete subListeners[subid];\n        trySend([\"CLOSE\", subid]);\n      },\n      on: (type, cb) => {\n        subListeners[subid] = subListeners[subid] || {\n          event: [],\n          eose: []\n        };\n        subListeners[subid][type].push(cb);\n      },\n      off: (type, cb) => {\n        let listeners2 = subListeners[subid];\n        let idx = listeners2[type].indexOf(cb);\n        if (idx >= 0)\n          listeners2[type].splice(idx, 1);\n      }\n    };\n  };\n  return {\n    url,\n    sub,\n    on: (type, cb) => {\n      listeners[type].push(cb);\n      if (type === \"connect\" && ws?.readyState === 1) {\n        ;\n        cb();\n      }\n    },\n    off: (type, cb) => {\n      let index = listeners[type].indexOf(cb);\n      if (index !== -1)\n        listeners[type].splice(index, 1);\n    },\n    list: (filters, opts) => new Promise((resolve) => {\n      let s = sub(filters, opts);\n      let events = [];\n      let timeout = setTimeout(() => {\n        s.unsub();\n        resolve(events);\n      }, listTimeout);\n      s.on(\"eose\", () => {\n        s.unsub();\n        clearTimeout(timeout);\n        resolve(events);\n      });\n      s.on(\"event\", (event) => {\n        events.push(event);\n      });\n    }),\n    get: (filter, opts) => new Promise((resolve) => {\n      let s = sub([filter], opts);\n      let timeout = setTimeout(() => {\n        s.unsub();\n        resolve(null);\n      }, getTimeout);\n      s.on(\"event\", (event) => {\n        s.unsub();\n        clearTimeout(timeout);\n        resolve(event);\n      });\n    }),\n    publish(event) {\n      if (!event.id)\n        throw new Error(`event ${event} has no id`);\n      let id = event.id;\n      trySend([\"EVENT\", event]);\n      return {\n        on: (type, cb) => {\n          pubListeners[id] = pubListeners[id] || {\n            ok: [],\n            failed: []\n          };\n          pubListeners[id][type].push(cb);\n        },\n        off: (type, cb) => {\n          let listeners2 = pubListeners[id];\n          if (!listeners2)\n            return;\n          let idx = listeners2[type].indexOf(cb);\n          if (idx >= 0)\n            listeners2[type].splice(idx, 1);\n        }\n      };\n    },\n    connect,\n    close() {\n      listeners = { connect: [], disconnect: [], error: [], notice: [] };\n      subListeners = {};\n      pubListeners = {};\n      if (ws.readyState === WebSocket.OPEN) {\n        ws?.close();\n      }\n    },\n    get status() {\n      return ws?.readyState ?? 3;\n    }\n  };\n}\n\n// pool.ts\nvar SimplePool = class {\n  _conn;\n  _seenOn = {};\n  eoseSubTimeout;\n  getTimeout;\n  constructor(options = {}) {\n    this._conn = {};\n    this.eoseSubTimeout = options.eoseSubTimeout || 3400;\n    this.getTimeout = options.getTimeout || 3400;\n  }\n  close(relays) {\n    relays.forEach((url) => {\n      let relay = this._conn[normalizeURL(url)];\n      if (relay)\n        relay.close();\n    });\n  }\n  async ensureRelay(url) {\n    const nm = normalizeURL(url);\n    const existing = this._conn[nm];\n    if (existing && existing.status === 1)\n      return existing;\n    if (existing) {\n      await existing.connect();\n      return existing;\n    }\n    const relay = relayInit(nm, {\n      getTimeout: this.getTimeout * 0.9,\n      listTimeout: this.getTimeout * 0.9\n    });\n    this._conn[nm] = relay;\n    await relay.connect();\n    return relay;\n  }\n  sub(relays, filters, opts) {\n    let _knownIds = /* @__PURE__ */ new Set();\n    let modifiedOpts = { ...opts || {} };\n    modifiedOpts.alreadyHaveEvent = (id, url) => {\n      if (opts?.alreadyHaveEvent?.(id, url)) {\n        return true;\n      }\n      let set = this._seenOn[id] || /* @__PURE__ */ new Set();\n      set.add(url);\n      this._seenOn[id] = set;\n      return _knownIds.has(id);\n    };\n    let subs = [];\n    let eventListeners = /* @__PURE__ */ new Set();\n    let eoseListeners = /* @__PURE__ */ new Set();\n    let eosesMissing = relays.length;\n    let eoseSent = false;\n    let eoseTimeout = setTimeout(() => {\n      eoseSent = true;\n      for (let cb of eoseListeners.values())\n        cb();\n    }, this.eoseSubTimeout);\n    relays.forEach(async (relay) => {\n      let r;\n      try {\n        r = await this.ensureRelay(relay);\n      } catch (err) {\n        handleEose();\n        return;\n      }\n      if (!r)\n        return;\n      let s = r.sub(filters, modifiedOpts);\n      s.on(\"event\", (event) => {\n        _knownIds.add(event.id);\n        for (let cb of eventListeners.values())\n          cb(event);\n      });\n      s.on(\"eose\", () => {\n        if (eoseSent)\n          return;\n        handleEose();\n      });\n      subs.push(s);\n      function handleEose() {\n        eosesMissing--;\n        if (eosesMissing === 0) {\n          clearTimeout(eoseTimeout);\n          for (let cb of eoseListeners.values())\n            cb();\n        }\n      }\n    });\n    let greaterSub = {\n      sub(filters2, opts2) {\n        subs.forEach((sub) => sub.sub(filters2, opts2));\n        return greaterSub;\n      },\n      unsub() {\n        subs.forEach((sub) => sub.unsub());\n      },\n      on(type, cb) {\n        if (type === \"event\") {\n          eventListeners.add(cb);\n        } else if (type === \"eose\") {\n          eoseListeners.add(cb);\n        }\n      },\n      off(type, cb) {\n        if (type === \"event\") {\n          eventListeners.delete(cb);\n        } else if (type === \"eose\")\n          eoseListeners.delete(cb);\n      }\n    };\n    return greaterSub;\n  }\n  get(relays, filter, opts) {\n    return new Promise((resolve) => {\n      let sub = this.sub(relays, [filter], opts);\n      let timeout = setTimeout(() => {\n        sub.unsub();\n        resolve(null);\n      }, this.getTimeout);\n      sub.on(\"event\", (event) => {\n        resolve(event);\n        clearTimeout(timeout);\n        sub.unsub();\n      });\n    });\n  }\n  list(relays, filters, opts) {\n    return new Promise((resolve) => {\n      let events = [];\n      let sub = this.sub(relays, filters, opts);\n      sub.on(\"event\", (event) => {\n        events.push(event);\n      });\n      sub.on(\"eose\", () => {\n        sub.unsub();\n        resolve(events);\n      });\n    });\n  }\n  publish(relays, event) {\n    const pubs = [];\n    relays.forEach(async (relay) => {\n      let r;\n      try {\n        r = await this.ensureRelay(relay);\n        pubs.push(r.publish(event));\n      } catch (_) {\n      }\n    });\n    return {\n      on(type, cb) {\n        pubs.forEach((pub, i) => {\n          pub.on(type, () => cb(relays[i]));\n        });\n      },\n      off() {\n      }\n    };\n  }\n  seenOn(id) {\n    return Array.from(this._seenOn[id]?.values?.() || []);\n  }\n};\n\n// nip04.ts\nvar nip04_exports = {};\n__export(nip04_exports, {\n  decrypt: () => decrypt,\n  encrypt: () => encrypt\n});\n\n\n\nasync function encrypt(privkey, pubkey, text) {\n  const key = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.getSharedSecret(privkey, \"02\" + pubkey);\n  const normalizedKey = getNormalizedX(key);\n  let iv = Uint8Array.from((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes)(16));\n  let plaintext = utf8Encoder.encode(text);\n  let cryptoKey = await crypto.subtle.importKey(\n    \"raw\",\n    normalizedKey,\n    { name: \"AES-CBC\" },\n    false,\n    [\"encrypt\"]\n  );\n  let ciphertext = await crypto.subtle.encrypt(\n    { name: \"AES-CBC\", iv },\n    cryptoKey,\n    plaintext\n  );\n  let ctb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(ciphertext));\n  let ivb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(iv.buffer));\n  return `${ctb64}?iv=${ivb64}`;\n}\nasync function decrypt(privkey, pubkey, data) {\n  let [ctb64, ivb64] = data.split(\"?iv=\");\n  let key = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.getSharedSecret(privkey, \"02\" + pubkey);\n  let normalizedKey = getNormalizedX(key);\n  let cryptoKey = await crypto.subtle.importKey(\n    \"raw\",\n    normalizedKey,\n    { name: \"AES-CBC\" },\n    false,\n    [\"decrypt\"]\n  );\n  let ciphertext = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ctb64);\n  let iv = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ivb64);\n  let plaintext = await crypto.subtle.decrypt(\n    { name: \"AES-CBC\", iv },\n    cryptoKey,\n    ciphertext\n  );\n  let text = utf8Decoder.decode(plaintext);\n  return text;\n}\nfunction getNormalizedX(key) {\n  return key.slice(1, 33);\n}\n\n// nip05.ts\nvar nip05_exports = {};\n__export(nip05_exports, {\n  queryProfile: () => queryProfile,\n  searchDomain: () => searchDomain,\n  useFetchImplementation: () => useFetchImplementation\n});\nvar _fetch;\ntry {\n  _fetch = fetch;\n} catch {\n}\nfunction useFetchImplementation(fetchImplementation) {\n  _fetch = fetchImplementation;\n}\nasync function searchDomain(domain, query = \"\") {\n  try {\n    let res = await (await _fetch(`https://${domain}/.well-known/nostr.json?name=${query}`)).json();\n    return res.names;\n  } catch (_) {\n    return {};\n  }\n}\nasync function queryProfile(fullname) {\n  let [name, domain] = fullname.split(\"@\");\n  if (!domain) {\n    domain = name;\n    name = \"_\";\n  }\n  if (!name.match(/^[A-Za-z0-9-_]+$/))\n    return null;\n  if (!domain.includes(\".\"))\n    return null;\n  let res;\n  try {\n    res = await (await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`)).json();\n  } catch (err) {\n    return null;\n  }\n  if (!res?.names?.[name])\n    return null;\n  let pubkey = res.names[name];\n  let relays = res.relays?.[pubkey] || [];\n  return {\n    pubkey,\n    relays\n  };\n}\n\n// nip06.ts\nvar nip06_exports = {};\n__export(nip06_exports, {\n  generateSeedWords: () => generateSeedWords,\n  privateKeyFromSeedWords: () => privateKeyFromSeedWords,\n  validateWords: () => validateWords\n});\n\n\n\n\nfunction privateKeyFromSeedWords(mnemonic, passphrase) {\n  let root = _scure_bip32__WEBPACK_IMPORTED_MODULE_6__.HDKey.fromMasterSeed((0,_scure_bip39__WEBPACK_IMPORTED_MODULE_5__.mnemonicToSeedSync)(mnemonic, passphrase));\n  let privateKey = root.derive(`m/44'/1237'/0'/0/0`).privateKey;\n  if (!privateKey)\n    throw new Error(\"could not derive private key\");\n  return _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.bytesToHex(privateKey);\n}\nfunction generateSeedWords() {\n  return (0,_scure_bip39__WEBPACK_IMPORTED_MODULE_5__.generateMnemonic)(_scure_bip39_wordlists_english_js__WEBPACK_IMPORTED_MODULE_4__.wordlist);\n}\nfunction validateWords(words) {\n  return (0,_scure_bip39__WEBPACK_IMPORTED_MODULE_5__.validateMnemonic)(words, _scure_bip39_wordlists_english_js__WEBPACK_IMPORTED_MODULE_4__.wordlist);\n}\n\n// nip19.ts\nvar nip19_exports = {};\n__export(nip19_exports, {\n  decode: () => decode,\n  naddrEncode: () => naddrEncode,\n  neventEncode: () => neventEncode,\n  noteEncode: () => noteEncode,\n  nprofileEncode: () => nprofileEncode,\n  npubEncode: () => npubEncode,\n  nsecEncode: () => nsecEncode\n});\n\n\nvar Bech32MaxSize = 5e3;\nfunction decode(nip19) {\n  let { prefix, words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(nip19, Bech32MaxSize);\n  let data = new Uint8Array(_scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words));\n  switch (prefix) {\n    case \"nprofile\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nprofile\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      return {\n        type: \"nprofile\",\n        data: {\n          pubkey: _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.bytesToHex(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nevent\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nevent\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      return {\n        type: \"nevent\",\n        data: {\n          id: _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.bytesToHex(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"naddr\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for naddr\");\n      if (!tlv[2]?.[0])\n        throw new Error(\"missing TLV 2 for naddr\");\n      if (tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (!tlv[3]?.[0])\n        throw new Error(\"missing TLV 3 for naddr\");\n      if (tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"naddr\",\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.bytesToHex(tlv[2][0]),\n          kind: parseInt(_noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.bytesToHex(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nsec\":\n    case \"npub\":\n    case \"note\":\n      return { type: prefix, data: _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.bytesToHex(data) };\n    default:\n      throw new Error(`unknown prefix ${prefix}`);\n  }\n}\nfunction parseTLV(data) {\n  let result = {};\n  let rest = data;\n  while (rest.length > 0) {\n    let t = rest[0];\n    let l = rest[1];\n    let v = rest.slice(2, 2 + l);\n    rest = rest.slice(2 + l);\n    if (v.length < l)\n      continue;\n    result[t] = result[t] || [];\n    result[t].push(v);\n  }\n  return result;\n}\nfunction nsecEncode(hex) {\n  return encodeBytes(\"nsec\", hex);\n}\nfunction npubEncode(hex) {\n  return encodeBytes(\"npub\", hex);\n}\nfunction noteEncode(hex) {\n  return encodeBytes(\"note\", hex);\n}\nfunction encodeBytes(prefix, hex) {\n  let data = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.hexToBytes(hex);\n  let words = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.toWords(data);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.encode(prefix, words, Bech32MaxSize);\n}\nfunction nprofileEncode(profile) {\n  let data = encodeTLV({\n    0: [_noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.hexToBytes(profile.pubkey)],\n    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))\n  });\n  let words = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.toWords(data);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.encode(\"nprofile\", words, Bech32MaxSize);\n}\nfunction neventEncode(event) {\n  let data = encodeTLV({\n    0: [_noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.hexToBytes(event.id)],\n    1: (event.relays || []).map((url) => utf8Encoder.encode(url))\n  });\n  let words = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.toWords(data);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.encode(\"nevent\", words, Bech32MaxSize);\n}\nfunction naddrEncode(addr) {\n  let kind = new ArrayBuffer(4);\n  new DataView(kind).setUint32(0, addr.kind, false);\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: [_noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.hexToBytes(addr.pubkey)],\n    3: [new Uint8Array(kind)]\n  });\n  let words = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.toWords(data);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.encode(\"naddr\", words, Bech32MaxSize);\n}\nfunction encodeTLV(tlv) {\n  let entries = [];\n  Object.entries(tlv).forEach(([t, vs]) => {\n    vs.forEach((v) => {\n      let entry = new Uint8Array(v.length + 2);\n      entry.set([parseInt(t)], 0);\n      entry.set([v.length], 1);\n      entry.set(v, 2);\n      entries.push(entry);\n    });\n  });\n  return _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.concatBytes(...entries);\n}\n\n// nip26.ts\nvar nip26_exports = {};\n__export(nip26_exports, {\n  createDelegation: () => createDelegation,\n  getDelegator: () => getDelegator\n});\n\n\nfunction createDelegation(privateKey, parameters) {\n  let conditions = [];\n  if ((parameters.kind || -1) >= 0)\n    conditions.push(`kind=${parameters.kind}`);\n  if (parameters.until)\n    conditions.push(`created_at<${parameters.until}`);\n  if (parameters.since)\n    conditions.push(`created_at>${parameters.since}`);\n  let cond = conditions.join(\"&\");\n  if (cond === \"\")\n    throw new Error(\"refusing to create a delegation without any conditions\");\n  let sighash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(\n    utf8Encoder.encode(`nostr:delegation:${parameters.pubkey}:${cond}`)\n  );\n  let sig = _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.bytesToHex(\n    _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.schnorr.signSync(sighash, privateKey)\n  );\n  return {\n    from: getPublicKey(privateKey),\n    to: parameters.pubkey,\n    cond,\n    sig\n  };\n}\nfunction getDelegator(event) {\n  let tag = event.tags.find((tag2) => tag2[0] === \"delegation\" && tag2.length >= 4);\n  if (!tag)\n    return null;\n  let pubkey = tag[1];\n  let cond = tag[2];\n  let sig = tag[3];\n  let conditions = cond.split(\"&\");\n  for (let i = 0; i < conditions.length; i++) {\n    let [key, operator, value] = conditions[i].split(/\\b/);\n    if (key === \"kind\" && operator === \"=\" && event.kind === parseInt(value))\n      continue;\n    else if (key === \"created_at\" && operator === \"<\" && event.created_at < parseInt(value))\n      continue;\n    else if (key === \"created_at\" && operator === \">\" && event.created_at > parseInt(value))\n      continue;\n    else\n      return null;\n  }\n  let sighash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(\n    utf8Encoder.encode(`nostr:delegation:${event.pubkey}:${cond}`)\n  );\n  if (!_noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.schnorr.verifySync(sig, sighash, pubkey))\n    return null;\n  return pubkey;\n}\n\n// nip39.ts\nvar nip39_exports = {};\n__export(nip39_exports, {\n  useFetchImplementation: () => useFetchImplementation2,\n  validateGithub: () => validateGithub\n});\nvar _fetch2;\ntry {\n  _fetch2 = fetch;\n} catch {\n}\nfunction useFetchImplementation2(fetchImplementation) {\n  _fetch2 = fetchImplementation;\n}\nasync function validateGithub(pubkey, username, proof) {\n  try {\n    let res = await (await _fetch2(`https://gist.github.com/${username}/${proof}/raw`)).text();\n    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;\n  } catch (_) {\n    return false;\n  }\n}\n\n// nip57.ts\nvar nip57_exports = {};\n__export(nip57_exports, {\n  getZapEndpoint: () => getZapEndpoint,\n  makeZapReceipt: () => makeZapReceipt,\n  makeZapRequest: () => makeZapRequest,\n  useFetchImplementation: () => useFetchImplementation3,\n  validateZapRequest: () => validateZapRequest\n});\n\nvar _fetch3;\ntry {\n  _fetch3 = fetch;\n} catch {\n}\nfunction useFetchImplementation3(fetchImplementation) {\n  _fetch3 = fetchImplementation;\n}\nasync function getZapEndpoint(metadata) {\n  try {\n    let lnurl = \"\";\n    let { lud06, lud16 } = JSON.parse(metadata.content);\n    if (lud06) {\n      let { words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(lud06, 1e3);\n      let data = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words);\n      lnurl = utf8Decoder.decode(data);\n    } else if (lud16) {\n      let [name, domain] = lud16.split(\"@\");\n      lnurl = `https://${domain}/.well-known/lnurlp/${name}`;\n    } else {\n      return null;\n    }\n    let res = await _fetch3(lnurl);\n    let body = await res.json();\n    if (body.allowsNostr && body.nostrPubkey) {\n      return body.callback;\n    }\n  } catch (err) {\n  }\n  return null;\n}\nfunction makeZapRequest({\n  profile,\n  event,\n  amount,\n  relays,\n  comment = \"\"\n}) {\n  if (!amount)\n    throw new Error(\"amount not given\");\n  if (!profile)\n    throw new Error(\"profile not given\");\n  let zr = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1e3),\n    content: comment,\n    tags: [\n      [\"p\", profile],\n      [\"amount\", amount.toString()],\n      [\"relays\", ...relays]\n    ]\n  };\n  if (event) {\n    zr.tags.push([\"e\", event]);\n  }\n  return zr;\n}\nfunction validateZapRequest(zapRequestString) {\n  let zapRequest;\n  try {\n    zapRequest = JSON.parse(zapRequestString);\n  } catch (err) {\n    return \"Invalid zap request JSON.\";\n  }\n  if (!validateEvent(zapRequest))\n    return \"Zap request is not a valid Nostr event.\";\n  if (!verifySignature(zapRequest))\n    return \"Invalid signature on zap request.\";\n  let p = zapRequest.tags.find(([t, v]) => t === \"p\" && v);\n  if (!p)\n    return \"Zap request doesn't have a 'p' tag.\";\n  if (!p[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'p' tag is not valid hex.\";\n  let e = zapRequest.tags.find(([t, v]) => t === \"e\" && v);\n  if (e && !e[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'e' tag is not valid hex.\";\n  let relays = zapRequest.tags.find(([t, v]) => t === \"relays\" && v);\n  if (!relays)\n    return \"Zap request doesn't have a 'relays' tag.\";\n  return null;\n}\nfunction makeZapReceipt({\n  zapRequest,\n  preimage,\n  bolt11,\n  paidAt\n}) {\n  let zr = JSON.parse(zapRequest);\n  let tagsFromZapRequest = zr.tags.filter(\n    ([t]) => t === \"e\" || t === \"p\" || t === \"a\"\n  );\n  let zap = {\n    kind: 9735,\n    created_at: Math.round(paidAt.getTime() / 1e3),\n    content: \"\",\n    tags: [\n      ...tagsFromZapRequest,\n      [\"bolt11\", bolt11],\n      [\"description\", zapRequest]\n    ]\n  };\n  if (preimage) {\n    zap.tags.push([\"preimage\", preimage]);\n  }\n  return zap;\n}\n\n// index.ts\n\n\n\n_noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.hmacSha256Sync = (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_7__.hmac)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, key, _noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.concatBytes(...msgs));\n_noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.sha256Sync = (...msgs) => (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(_noble_secp256k1__WEBPACK_IMPORTED_MODULE_0__.utils.concatBytes(...msgs));\n\n\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/nostr-tools/lib/esm/nostr.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/app/test.js");
/******/ 	
/******/ })()
;